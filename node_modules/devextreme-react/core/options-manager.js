/*!
 * devextreme-react
 * Version: 18.2.13
 * Build date: Wed May 27 2020
 *
 * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-react
 */

"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = require("react");
var helpers_1 = require("./helpers");
var nested_option_1 = require("./nested-option");
var widget_config_1 = require("./widget-config");
function isEventHanlder(optionName, optionValue) {
    return optionName.substr(0, 2) === "on" && typeof optionValue === "function";
}
var OptionsManager = /** @class */ (function () {
    function OptionsManager(optionValueGetter, templateHost) {
        this._guards = {};
        this._nestedOptions = {};
        this._dirtyOptions = {};
        this._optionValueGetter = optionValueGetter;
        this._templatesManager = templateHost;
        this._setOption = this._setOption.bind(this);
        this._syncOptions = this._syncOptions.bind(this);
        this._registerNestedOption = this._registerNestedOption.bind(this);
        this.registerNestedOption = this.registerNestedOption.bind(this);
        this.handleOptionChange = this.handleOptionChange.bind(this);
        this.updateOptions = this.updateOptions.bind(this);
    }
    OptionsManager.prototype.resetNestedElements = function () {
        var _this = this;
        Object.keys(this._nestedOptions).forEach(function (optionName) {
            _this._nestedOptions[optionName].elementEntries.length = 0;
        });
    };
    OptionsManager.prototype.setInstance = function (instance) {
        this._instance = instance;
    };
    OptionsManager.prototype.wrapEventHandlers = function (options) {
        var _this = this;
        Object.keys(options).forEach(function (name) {
            var value = options[name];
            if (isEventHanlder(name, value)) {
                options[name] = _this._wrapEventHandler(value);
            }
        });
    };
    OptionsManager.prototype.handleOptionChange = function (e) {
        var _this = this;
        if (this._updatingProps) {
            return;
        }
        var optionValue;
        var optionName;
        var nestedOption = this._nestedOptions[e.name];
        if (nestedOption && nestedOption.elementEntries.length > 0) {
            optionName = e.fullName;
            var nestedOptionObj = widget_config_1.separateProps(nestedOption.elementEntries[0].element.props, nestedOption.defaults, []).options;
            if (e.name === e.fullName) {
                Object.keys(nestedOptionObj).forEach(function (key) { return _this.handleOptionChange({
                    name: e.name,
                    fullName: e.fullName + "." + key,
                    value: e.value[key]
                }); });
                return;
            }
            if (nestedOption.isCollectionItem) {
                return;
            }
            optionValue = helpers_1.getNestedValue(nestedOptionObj, e.fullName.split(".").slice(1));
        }
        else {
            var fullNameParts = e.fullName.split(".");
            if (fullNameParts.length > 1) {
                optionName = e.fullName;
                optionValue = helpers_1.getNestedValue(this._optionValueGetter(e.name), fullNameParts.slice(1));
            }
            else {
                optionName = e.name;
                optionValue = this._optionValueGetter(e.name);
            }
        }
        if (optionValue === undefined || optionValue === null) {
            return;
        }
        this._setGuard(optionName, optionValue);
    };
    OptionsManager.prototype.updateOptions = function (newProps, prevProps) {
        var _this = this;
        var nestedOptions = {};
        Object.keys(this._dirtyOptions).forEach(function (optionName) {
            var optionDescr = _this._dirtyOptions[optionName];
            var optionValue = _this._getNestedOptionObj(optionDescr, true);
            nestedOptions[optionName] = optionValue;
        });
        var newOptions = __assign({}, this._templatesManager.options, nestedOptions, newProps);
        this._syncOptions(newOptions, prevProps);
        this._dirtyOptions = {};
    };
    OptionsManager.prototype.getNestedOptionsObjects = function () {
        return this._getNestedOptionsObjects(this._nestedOptions, true);
    };
    OptionsManager.prototype.registerNestedOption = function (component, expectedChildren) {
        return this._registerNestedOption(component, expectedChildren, this._nestedOptions);
    };
    OptionsManager.prototype.dispose = function () {
        for (var _i = 0, _a = Object.keys(this._guards); _i < _a.length; _i++) {
            var optionName = _a[_i];
            window.clearTimeout(this._guards[optionName]);
            delete this._guards[optionName];
        }
    };
    OptionsManager.prototype._syncOptions = function (newOptions, prevOptions) {
        this._updatingProps = false;
        for (var _i = 0, _a = Object.keys(newOptions); _i < _a.length; _i++) {
            var optionName = _a[_i];
            if (newOptions[optionName] === prevOptions[optionName]) {
                continue;
            }
            if (this._guards[optionName]) {
                window.clearTimeout(this._guards[optionName]);
                delete this._guards[optionName];
            }
            if (!this._updatingProps) {
                this._instance.beginUpdate();
                this._updatingProps = true;
            }
            this._setOption(optionName, newOptions[optionName]);
        }
        if (this._updatingProps) {
            this._updatingProps = false;
            this._instance.endUpdate();
        }
    };
    OptionsManager.prototype._setOption = function (name, value) {
        var actualValue = value;
        if (isEventHanlder(name, value)) {
            actualValue = this._wrapEventHandler(value);
        }
        this._instance.option(name, actualValue);
    };
    OptionsManager.prototype._wrapEventHandler = function (handler) {
        var _this = this;
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (!_this._updatingProps) {
                handler.apply(void 0, args);
            }
        };
    };
    OptionsManager.prototype._getNestedOptionsObjects = function (optionsCollection, templateRegistrationRequired) {
        var _this = this;
        var configComponents = {};
        Object.keys(optionsCollection).forEach(function (key) {
            var configComponent = optionsCollection[key];
            configComponents[configComponent.optionName] = _this._getNestedOptionObj(configComponent, templateRegistrationRequired);
        });
        return configComponents;
    };
    OptionsManager.prototype._getNestedOptionObj = function (configComponent, templateRegistrationRequired) {
        var _this = this;
        var options = configComponent.elementEntries.map(function (e, index) {
            var props = widget_config_1.separateProps(e.element.props, configComponent.defaults, configComponent.templates);
            var nestedObjects = _this._getNestedOptionsObjects(e.children, templateRegistrationRequired);
            var nestedObjectsCount = Object.keys(nestedObjects).reduce(function (acc, item) {
                var obj = nestedObjects[item];
                return acc + (Array.isArray(obj) ? obj.length : 1);
            }, 0);
            var hasChildrenForTemplate = react_1.Children.count(e.element.props.children) > nestedObjectsCount;
            var templatesOptions = {};
            if (templateRegistrationRequired) {
                templatesOptions = _this._templatesManager.add({
                    useChildren: function (optionName) {
                        return optionName === "template" && hasChildrenForTemplate;
                    },
                    props: props.templates,
                    templateProps: configComponent.templates,
                    ownerName: _this.buildOptionItemName(configComponent, configComponent.isCollectionItem ? index : undefined),
                    propsGetter: function (prop) {
                        var nestedElement = configComponent.elementEntries[index];
                        if (!nestedElement) {
                            return;
                        }
                        return nestedElement.element.props[prop];
                    }
                });
            }
            return __assign({}, e.predefinedProps, props.defaults, props.options, nestedObjects, templatesOptions);
        });
        return configComponent.isCollectionItem
            ? options
            : options[options.length - 1];
    };
    OptionsManager.prototype._registerNestedOption = function (element, expectedChildren, owningCollection, ownerFullName) {
        var _this = this;
        var nestedOptionClass = element;
        if (!(nestedOptionClass && nestedOptionClass.type && nestedOptionClass.type.OptionName)) {
            return null;
        }
        var nestedOptionsCollection = {};
        var resolvedNested = resolveNestedOption(nestedOptionClass.type.OptionName, nestedOptionClass.type.IsCollectionItem, expectedChildren);
        var optionName = resolvedNested.optionName;
        var isCollectionItem = resolvedNested.isCollectionItem;
        var optionFullName = optionName;
        if (ownerFullName) {
            optionFullName = ownerFullName + "." + optionFullName;
        }
        var option = ensureNestedOption(optionName, optionFullName, owningCollection, nestedOptionClass.type.DefaultsProps, nestedOptionClass.type.TemplateProps, isCollectionItem);
        var optionItemName = this.buildOptionItemName(option, isCollectionItem ? option.elementEntries.length : undefined);
        var nestedOptionMeta = {
            optionName: optionName,
            registerNestedOption: function (c) {
                return _this._registerNestedOption(c, nestedOptionClass.type.ExpectedChildren, nestedOptionsCollection, optionItemName);
            },
            updateFunc: function (newProps, prevProps) {
                var newOptions = widget_config_1.separateProps(newProps, nestedOptionClass.type.DefaultsProps, nestedOptionClass.type.TemplateProps).options;
                _this._syncOptions(helpers_1.addPrefixToKeys(newOptions, optionItemName + "."), helpers_1.addPrefixToKeys(prevProps, optionItemName + "."));
            },
            makeDirty: function () {
                if (_this._instance && option.isCollectionItem) {
                    _this._dirtyOptions[option.optionName] = option;
                }
            }
        };
        var optionComponent = nested_option_1.createOptionComponent(element, nestedOptionMeta);
        option.elementEntries.push({
            element: element,
            children: nestedOptionsCollection,
            predefinedProps: nestedOptionClass.type.PredefinedProps
        });
        return optionComponent;
    };
    OptionsManager.prototype.buildOptionItemName = function (descr, index) {
        var optionItemName = descr.optionFullName;
        if (index !== undefined) {
            optionItemName += "[" + index + "]";
        }
        return optionItemName;
    };
    OptionsManager.prototype._setGuard = function (optionName, optionValue) {
        var _this = this;
        if (this._guards[optionName] !== undefined) {
            return;
        }
        var guardId = window.setTimeout(function () {
            _this._setOption(optionName, optionValue);
            window.clearTimeout(guardId);
            delete _this._guards[optionName];
        });
        this._guards[optionName] = guardId;
    };
    return OptionsManager;
}());
function ensureNestedOption(optionName, optionFullName, optionsCollection, defaults, templates, isCollectionItem) {
    if (optionsCollection[optionName] === null ||
        optionsCollection[optionName] === undefined) {
        optionsCollection[optionName] = {
            optionName: optionName,
            optionFullName: optionFullName,
            defaults: defaults,
            templates: templates,
            elementEntries: [],
            isCollectionItem: isCollectionItem
        };
    }
    return optionsCollection[optionName];
}
function resolveNestedOption(componentName, canBeCollectionItem, expectations) {
    var optionName = componentName;
    var isCollectionItem = canBeCollectionItem;
    var expectation = expectations && expectations[componentName];
    if (expectation) {
        isCollectionItem = expectation.isCollectionItem;
        if (expectation.optionName) {
            optionName = expectation.optionName;
        }
    }
    return { optionName: optionName, isCollectionItem: isCollectionItem };
}
exports.resolveNestedOption = resolveNestedOption;
exports.default = OptionsManager;
