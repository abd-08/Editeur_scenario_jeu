{"ast":null,"code":"/**\r\n * DevExtreme (ui/widget/ui.widget.js)\r\n * Version: 18.2.8\r\n * Build date: Tue Apr 23 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar $ = require(\"../../core/renderer\"),\n    eventsEngine = require(\"../../events/core/events_engine\"),\n    errors = require(\"./ui.errors\"),\n    Action = require(\"../../core/action\"),\n    extend = require(\"../../core/utils/extend\").extend,\n    inArray = require(\"../../core/utils/array\").inArray,\n    each = require(\"../../core/utils/iterator\").each,\n    commonUtils = require(\"../../core/utils/common\"),\n    typeUtils = require(\"../../core/utils/type\"),\n    domUtils = require(\"../../core/utils/dom\"),\n    domAdapter = require(\"../../core/dom_adapter\"),\n    devices = require(\"../../core/devices\"),\n    DOMComponent = require(\"../../core/dom_component\"),\n    Template = require(\"./template\"),\n    TemplateBase = require(\"./ui.template_base\"),\n    FunctionTemplate = require(\"./function_template\"),\n    EmptyTemplate = require(\"./empty_template\"),\n    ChildDefaultTemplate = require(\"./child_default_template\"),\n    KeyboardProcessor = require(\"./ui.keyboard_processor\"),\n    selectors = require(\"./selectors\"),\n    eventUtils = require(\"../../events/utils\"),\n    hoverEvents = require(\"../../events/hover\"),\n    feedbackEvents = require(\"../../events/core/emitter.feedback\"),\n    clickEvent = require(\"../../events/click\"),\n    inflector = require(\"../../core/utils/inflector\");\n\nvar UI_FEEDBACK = \"UIFeedback\",\n    WIDGET_CLASS = \"dx-widget\",\n    ACTIVE_STATE_CLASS = \"dx-state-active\",\n    DISABLED_STATE_CLASS = \"dx-state-disabled\",\n    INVISIBLE_STATE_CLASS = \"dx-state-invisible\",\n    HOVER_STATE_CLASS = \"dx-state-hover\",\n    FOCUSED_STATE_CLASS = \"dx-state-focused\",\n    FEEDBACK_SHOW_TIMEOUT = 30,\n    FEEDBACK_HIDE_TIMEOUT = 400,\n    FOCUS_NAMESPACE = \"Focus\",\n    ANONYMOUS_TEMPLATE_NAME = \"template\",\n    TEXT_NODE = 3,\n    TEMPLATE_SELECTOR = \"[data-options*='dxTemplate']\",\n    TEMPLATE_WRAPPER_CLASS = \"dx-template-wrapper\";\nvar DX_POLYMORPH_WIDGET_TEMPLATE = new FunctionTemplate(function (options) {\n  var widgetName = options.model.widget;\n\n  if (widgetName) {\n    var widgetElement = $(\"<div>\"),\n        widgetOptions = options.model.options || {};\n\n    if (\"button\" === widgetName || \"tabs\" === widgetName || \"dropDownMenu\" === widgetName) {\n      var deprecatedName = widgetName;\n      widgetName = inflector.camelize(\"dx-\" + widgetName);\n      errors.log(\"W0001\", \"dxToolbar - 'widget' item field\", deprecatedName, \"16.1\", \"Use: '\" + widgetName + \"' instead\");\n    }\n\n    if (options.parent) {\n      options.parent._createComponent(widgetElement, widgetName, widgetOptions);\n    } else {\n      widgetElement[widgetName](widgetOptions);\n    }\n\n    return widgetElement;\n  }\n\n  return $();\n});\nvar Widget = DOMComponent.inherit({\n  _supportedKeys: function _supportedKeys() {\n    return {};\n  },\n  _getDefaultOptions: function _getDefaultOptions() {\n    return extend(this.callBase(), {\n      disabled: false,\n      visible: true,\n      hint: void 0,\n      activeStateEnabled: false,\n      onContentReady: null,\n      hoverStateEnabled: false,\n      focusStateEnabled: false,\n      tabIndex: 0,\n      accessKey: null,\n      onFocusIn: null,\n      onFocusOut: null,\n      integrationOptions: {\n        watchMethod: function watchMethod(fn, callback, options) {\n          options = options || {};\n\n          if (!options.skipImmediate) {\n            callback(fn());\n          }\n\n          return commonUtils.noop;\n        },\n        templates: {\n          \"dx-polymorph-widget\": DX_POLYMORPH_WIDGET_TEMPLATE\n        },\n        createTemplate: function createTemplate(element) {\n          return new Template(element);\n        }\n      },\n      _keyboardProcessor: void 0\n    });\n  },\n  _feedbackShowTimeout: FEEDBACK_SHOW_TIMEOUT,\n  _feedbackHideTimeout: FEEDBACK_HIDE_TIMEOUT,\n  _init: function _init() {\n    this.callBase();\n    this._tempTemplates = [];\n    this._defaultTemplates = {};\n\n    this._initTemplates();\n\n    this._initContentReadyAction();\n  },\n  _initTemplates: function _initTemplates() {\n    this._extractTemplates();\n\n    this._extractAnonymousTemplate();\n  },\n  _clearInnerOptionCache: function _clearInnerOptionCache(optionContainer) {\n    this[optionContainer + \"Cache\"] = {};\n  },\n  _cacheInnerOptions: function _cacheInnerOptions(optionContainer, optionValue) {\n    var cacheName = optionContainer + \"Cache\";\n    this[cacheName] = extend(this[cacheName], optionValue);\n  },\n  _getInnerOptionsCache: function _getInnerOptionsCache(optionContainer) {\n    return this[optionContainer + \"Cache\"];\n  },\n  _initInnerOptionCache: function _initInnerOptionCache(optionContainer) {\n    this._clearInnerOptionCache(optionContainer);\n\n    this._cacheInnerOptions(optionContainer, this.option(optionContainer));\n  },\n  _bindInnerWidgetOptions: function _bindInnerWidgetOptions(innerWidget, optionsContainer) {\n    this._options[optionsContainer] = extend({}, innerWidget.option());\n    innerWidget.on(\"optionChanged\", function (e) {\n      this._options[optionsContainer] = extend({}, e.component.option());\n    }.bind(this));\n  },\n  _extractTemplates: function _extractTemplates() {\n    var templateElements = this.$element().contents().filter(TEMPLATE_SELECTOR);\n    var templatesMap = {};\n    templateElements.each(function (_, template) {\n      var templateOptions = domUtils.getElementOptions(template).dxTemplate;\n\n      if (!templateOptions) {\n        return;\n      }\n\n      if (!templateOptions.name) {\n        throw errors.Error(\"E0023\");\n      }\n\n      $(template).addClass(TEMPLATE_WRAPPER_CLASS).detach();\n      templatesMap[templateOptions.name] = templatesMap[templateOptions.name] || [];\n      templatesMap[templateOptions.name].push(template);\n    });\n    each(templatesMap, function (templateName, value) {\n      var deviceTemplate = this._findTemplateByDevice(value);\n\n      if (deviceTemplate) {\n        this._saveTemplate(templateName, deviceTemplate);\n      }\n    }.bind(this));\n  },\n  _saveTemplate: function _saveTemplate(name, template) {\n    var templates = this.option(\"integrationOptions.templates\");\n    templates[name] = this._createTemplate(template);\n  },\n  _findTemplateByDevice: function _findTemplateByDevice(templates) {\n    var suitableTemplate = commonUtils.findBestMatches(devices.current(), templates, function (template) {\n      return domUtils.getElementOptions(template).dxTemplate;\n    })[0];\n    each(templates, function (index, template) {\n      if (template !== suitableTemplate) {\n        $(template).remove();\n      }\n    });\n    return suitableTemplate;\n  },\n  _extractAnonymousTemplate: function _extractAnonymousTemplate() {\n    var templates = this.option(\"integrationOptions.templates\"),\n        anonymousTemplateName = this._getAnonymousTemplateName(),\n        $anonymousTemplate = this.$element().contents().detach();\n\n    var $notJunkTemplateContent = $anonymousTemplate.filter(function (_, element) {\n      var isTextNode = element.nodeType === TEXT_NODE,\n          isEmptyText = $(element).text().trim().length < 1;\n      return !(isTextNode && isEmptyText);\n    }),\n        onlyJunkTemplateContent = $notJunkTemplateContent.length < 1;\n\n    if (!templates[anonymousTemplateName] && !onlyJunkTemplateContent) {\n      templates[anonymousTemplateName] = this._createTemplate($anonymousTemplate);\n    }\n  },\n  _getAriaTarget: function _getAriaTarget() {\n    return this._focusTarget();\n  },\n  _getAnonymousTemplateName: function _getAnonymousTemplateName() {\n    return ANONYMOUS_TEMPLATE_NAME;\n  },\n  _getTemplateByOption: function _getTemplateByOption(optionName) {\n    return this._getTemplate(this.option(optionName));\n  },\n  _getTemplate: function _getTemplate(templateSource) {\n    if (typeUtils.isFunction(templateSource)) {\n      return new FunctionTemplate(function (options) {\n        var templateSourceResult = templateSource.apply(this, this._getNormalizedTemplateArgs(options));\n\n        if (!typeUtils.isDefined(templateSourceResult)) {\n          return new EmptyTemplate();\n        }\n\n        var dispose = false;\n\n        var template = this._acquireTemplate(templateSourceResult, function (templateSource) {\n          if (templateSource.nodeType || typeUtils.isRenderer(templateSource) && !$(templateSource).is(\"script\")) {\n            return new FunctionTemplate(function () {\n              return templateSource;\n            });\n          }\n\n          dispose = true;\n          return this._createTemplate(templateSource);\n        }.bind(this));\n\n        var result = template.render(options);\n        dispose && template.dispose && template.dispose();\n        return result;\n      }.bind(this));\n    }\n\n    return this._acquireTemplate(templateSource, this._createTemplateIfNeeded.bind(this));\n  },\n  _acquireTemplate: function _acquireTemplate(templateSource, createTemplate) {\n    if (null == templateSource) {\n      return new EmptyTemplate();\n    }\n\n    if (templateSource instanceof ChildDefaultTemplate) {\n      return this._defaultTemplates[templateSource.name];\n    }\n\n    if (templateSource instanceof TemplateBase) {\n      return templateSource;\n    }\n\n    if (typeUtils.isFunction(templateSource.render) && !typeUtils.isRenderer(templateSource)) {\n      return this._addOneRenderedCall(templateSource);\n    }\n\n    if (templateSource.nodeType || typeUtils.isRenderer(templateSource)) {\n      return createTemplate($(templateSource));\n    }\n\n    if (\"string\" === typeof templateSource) {\n      return this._renderIntegrationTemplate(templateSource) || this._defaultTemplates[templateSource] || createTemplate(templateSource);\n    }\n\n    return this._acquireTemplate(templateSource.toString(), createTemplate);\n  },\n  _addOneRenderedCall: function _addOneRenderedCall(template) {\n    var _render = template.render.bind(template);\n\n    return extend({}, template, {\n      render: function render(options) {\n        var templateResult = _render(options);\n\n        options && options.onRendered && options.onRendered();\n        return templateResult;\n      }\n    });\n  },\n  _renderIntegrationTemplate: function _renderIntegrationTemplate(templateSource) {\n    var integrationTemplate = this.option(\"integrationOptions.templates\")[templateSource];\n\n    if (integrationTemplate && !(integrationTemplate instanceof TemplateBase)) {\n      var isAsyncTemplate = this.option(\"templatesRenderAsynchronously\");\n\n      if (!isAsyncTemplate) {\n        return this._addOneRenderedCall(integrationTemplate);\n      }\n    }\n\n    return integrationTemplate;\n  },\n  _createTemplateIfNeeded: function _createTemplateIfNeeded(templateSource) {\n    var templateKey = function templateKey(templateSource) {\n      return typeUtils.isRenderer(templateSource) && templateSource[0] || templateSource;\n    };\n\n    var cachedTemplate = this._tempTemplates.filter(function (t) {\n      templateSource = templateKey(templateSource);\n      return t.source === templateSource;\n    })[0];\n\n    if (cachedTemplate) {\n      return cachedTemplate.template;\n    }\n\n    var template = this._createTemplate(templateSource);\n\n    this._tempTemplates.push({\n      template: template,\n      source: templateKey(templateSource)\n    });\n\n    return template;\n  },\n  _createTemplate: function _createTemplate(templateSource) {\n    templateSource = \"string\" === typeof templateSource ? domUtils.normalizeTemplateElement(templateSource) : templateSource;\n    return this.option(\"integrationOptions.createTemplate\")(templateSource);\n  },\n  _getNormalizedTemplateArgs: function _getNormalizedTemplateArgs(options) {\n    var args = [];\n\n    if (\"model\" in options) {\n      args.push(options.model);\n    }\n\n    if (\"index\" in options) {\n      args.push(options.index);\n    }\n\n    args.push(options.container);\n    return args;\n  },\n  _cleanTemplates: function _cleanTemplates() {\n    this._tempTemplates.forEach(function (t) {\n      t.template.dispose && t.template.dispose();\n    });\n\n    this._tempTemplates = [];\n  },\n  _initContentReadyAction: function _initContentReadyAction() {\n    this._contentReadyAction = this._createActionByOption(\"onContentReady\", {\n      excludeValidators: [\"designMode\", \"disabled\", \"readOnly\"]\n    });\n  },\n  _initMarkup: function _initMarkup() {\n    this.$element().addClass(WIDGET_CLASS);\n\n    this._toggleDisabledState(this.option(\"disabled\"));\n\n    this._toggleVisibility(this.option(\"visible\"));\n\n    this._renderHint();\n\n    if (this._isFocusable()) {\n      this._renderFocusTarget();\n    }\n\n    this.callBase();\n  },\n  _render: function _render() {\n    this.callBase();\n\n    this._renderContent();\n\n    this._renderFocusState();\n\n    this._attachFeedbackEvents();\n\n    this._attachHoverEvents();\n  },\n  _renderHint: function _renderHint() {\n    domUtils.toggleAttr(this.$element(), \"title\", this.option(\"hint\"));\n  },\n  _renderContent: function _renderContent() {\n    var _this = this;\n\n    commonUtils.deferRender(function () {\n      if (_this._disposed) {\n        return;\n      }\n\n      return _this._renderContentImpl();\n    }).done(function () {\n      if (_this._disposed) {\n        return;\n      }\n\n      _this._fireContentReadyAction();\n    });\n  },\n  _renderContentImpl: commonUtils.noop,\n  _fireContentReadyAction: commonUtils.deferRenderer(function () {\n    this._contentReadyAction();\n  }),\n  _dispose: function _dispose() {\n    this._cleanTemplates();\n\n    this._contentReadyAction = null;\n    this.callBase();\n  },\n  _resetActiveState: function _resetActiveState() {\n    this._toggleActiveState(this._eventBindingTarget(), false);\n  },\n  _clean: function _clean() {\n    this._cleanFocusState();\n\n    this._resetActiveState();\n\n    this.callBase();\n    this.$element().empty();\n  },\n  _toggleVisibility: function _toggleVisibility(visible) {\n    this.$element().toggleClass(INVISIBLE_STATE_CLASS, !visible);\n    this.setAria(\"hidden\", !visible || void 0);\n  },\n  _renderFocusState: function _renderFocusState() {\n    this._attachKeyboardEvents();\n\n    if (!this._isFocusable()) {\n      return;\n    }\n\n    this._renderFocusTarget();\n\n    this._attachFocusEvents();\n\n    this._renderAccessKey();\n  },\n  _renderAccessKey: function _renderAccessKey() {\n    var focusTarget = this._focusTarget();\n\n    focusTarget.attr(\"accesskey\", this.option(\"accessKey\"));\n    var clickNamespace = eventUtils.addNamespace(clickEvent.name, UI_FEEDBACK);\n    eventsEngine.off(focusTarget, clickNamespace);\n    this.option(\"accessKey\") && eventsEngine.on(focusTarget, clickNamespace, function (e) {\n      if (eventUtils.isFakeClickEvent(e)) {\n        e.stopImmediatePropagation();\n        this.focus();\n      }\n    }.bind(this));\n  },\n  _isFocusable: function _isFocusable() {\n    return this.option(\"focusStateEnabled\") && !this.option(\"disabled\");\n  },\n  _eventBindingTarget: function _eventBindingTarget() {\n    return this.$element();\n  },\n  _focusTarget: function _focusTarget() {\n    return this._getActiveElement();\n  },\n  _getActiveElement: function _getActiveElement() {\n    var activeElement = this._eventBindingTarget();\n\n    if (this._activeStateUnit) {\n      activeElement = activeElement.find(this._activeStateUnit).not(\".\" + DISABLED_STATE_CLASS);\n    }\n\n    return activeElement;\n  },\n  _renderFocusTarget: function _renderFocusTarget() {\n    this._focusTarget().attr(\"tabIndex\", this.option(\"tabIndex\"));\n  },\n  _keyboardEventBindingTarget: function _keyboardEventBindingTarget() {\n    return this._eventBindingTarget();\n  },\n  _detachFocusEvents: function _detachFocusEvents() {\n    var $element = this._focusTarget(),\n        namespace = this.NAME + FOCUS_NAMESPACE,\n        focusEvents = eventUtils.addNamespace(\"focusin\", namespace);\n\n    focusEvents = focusEvents + \" \" + eventUtils.addNamespace(\"focusout\", namespace);\n\n    if (domAdapter.hasDocumentProperty(\"onbeforeactivate\")) {\n      focusEvents = focusEvents + \" \" + eventUtils.addNamespace(\"beforeactivate\", namespace);\n    }\n\n    eventsEngine.off($element, focusEvents);\n  },\n  _attachFocusEvents: function _attachFocusEvents() {\n    var namespace = this.NAME + FOCUS_NAMESPACE,\n        focusInEvent = eventUtils.addNamespace(\"focusin\", namespace),\n        focusOutEvent = eventUtils.addNamespace(\"focusout\", namespace);\n\n    var $focusTarget = this._focusTarget();\n\n    eventsEngine.on($focusTarget, focusInEvent, this._focusInHandler.bind(this));\n    eventsEngine.on($focusTarget, focusOutEvent, this._focusOutHandler.bind(this));\n\n    if (domAdapter.hasDocumentProperty(\"onbeforeactivate\")) {\n      var beforeActivateEvent = eventUtils.addNamespace(\"beforeactivate\", namespace);\n      eventsEngine.on(this._focusTarget(), beforeActivateEvent, function (e) {\n        if (!$(e.target).is(selectors.focusable)) {\n          e.preventDefault();\n        }\n      });\n    }\n  },\n  _refreshFocusEvent: function _refreshFocusEvent() {\n    this._detachFocusEvents();\n\n    this._attachFocusEvents();\n  },\n  _focusInHandler: function _focusInHandler(e) {\n    var that = this;\n\n    that._createActionByOption(\"onFocusIn\", {\n      beforeExecute: function beforeExecute() {\n        that._updateFocusState(e, true);\n      },\n      excludeValidators: [\"readOnly\"]\n    })({\n      event: e\n    });\n  },\n  _focusOutHandler: function _focusOutHandler(e) {\n    var that = this;\n\n    that._createActionByOption(\"onFocusOut\", {\n      beforeExecute: function beforeExecute() {\n        that._updateFocusState(e, false);\n      },\n      excludeValidators: [\"readOnly\", \"disabled\"]\n    })({\n      event: e\n    });\n  },\n  _updateFocusState: function _updateFocusState(e, isFocused) {\n    var target = e.target;\n\n    if (inArray(target, this._focusTarget()) !== -1) {\n      this._toggleFocusClass(isFocused, $(target));\n    }\n  },\n  _toggleFocusClass: function _toggleFocusClass(isFocused, $element) {\n    var $focusTarget = $element && $element.length ? $element : this._focusTarget();\n    $focusTarget.toggleClass(FOCUSED_STATE_CLASS, isFocused);\n  },\n  _hasFocusClass: function _hasFocusClass(element) {\n    var $focusTarget = $(element || this._focusTarget());\n    return $focusTarget.hasClass(FOCUSED_STATE_CLASS);\n  },\n  _isFocused: function _isFocused() {\n    return this._hasFocusClass();\n  },\n  _attachKeyboardEvents: function _attachKeyboardEvents() {\n    var processor = this.option(\"_keyboardProcessor\");\n\n    if (processor) {\n      this._keyboardProcessor = processor.reinitialize(this._keyboardHandler, this);\n    } else {\n      if (this.option(\"focusStateEnabled\")) {\n        this._keyboardProcessor = new KeyboardProcessor({\n          element: this._keyboardEventBindingTarget(),\n          handler: this._keyboardHandler,\n          focusTarget: this._focusTarget(),\n          context: this\n        });\n      }\n    }\n  },\n  _keyboardHandler: function _keyboardHandler(options) {\n    var e = options.originalEvent;\n    var keyName = options.keyName;\n    var keyCode = options.which;\n\n    var keys = this._supportedKeys(e),\n        func = keys[keyName] || keys[keyCode];\n\n    if (void 0 !== func) {\n      var handler = func.bind(this);\n      return handler(e) || false;\n    } else {\n      return true;\n    }\n  },\n  _refreshFocusState: function _refreshFocusState() {\n    this._cleanFocusState();\n\n    this._renderFocusState();\n  },\n  _cleanFocusState: function _cleanFocusState() {\n    var $element = this._focusTarget();\n\n    this._detachFocusEvents();\n\n    this._toggleFocusClass(false);\n\n    $element.removeAttr(\"tabIndex\");\n\n    this._disposeKeyboardProcessor();\n  },\n  _disposeKeyboardProcessor: function _disposeKeyboardProcessor() {\n    if (this._keyboardProcessor) {\n      this._keyboardProcessor.dispose();\n\n      delete this._keyboardProcessor;\n    }\n  },\n  _attachHoverEvents: function _attachHoverEvents() {\n    var that = this,\n        hoverableSelector = that._activeStateUnit,\n        nameStart = eventUtils.addNamespace(hoverEvents.start, UI_FEEDBACK),\n        nameEnd = eventUtils.addNamespace(hoverEvents.end, UI_FEEDBACK);\n    eventsEngine.off(that._eventBindingTarget(), nameStart, hoverableSelector);\n    eventsEngine.off(that._eventBindingTarget(), nameEnd, hoverableSelector);\n\n    if (that.option(\"hoverStateEnabled\")) {\n      var startAction = new Action(function (args) {\n        that._hoverStartHandler(args.event);\n\n        that._refreshHoveredElement($(args.element));\n      }, {\n        excludeValidators: [\"readOnly\"]\n      });\n\n      var $eventBindingTarget = that._eventBindingTarget();\n\n      eventsEngine.on($eventBindingTarget, nameStart, hoverableSelector, function (e) {\n        startAction.execute({\n          element: $(e.target),\n          event: e\n        });\n      });\n      eventsEngine.on($eventBindingTarget, nameEnd, hoverableSelector, function (e) {\n        that._hoverEndHandler(e);\n\n        that._forgetHoveredElement();\n      });\n    } else {\n      that._toggleHoverClass(false);\n    }\n  },\n  _hoverStartHandler: commonUtils.noop,\n  _hoverEndHandler: commonUtils.noop,\n  _attachFeedbackEvents: function _attachFeedbackEvents() {\n    var feedbackAction,\n        feedbackActionDisabled,\n        that = this,\n        feedbackSelector = that._activeStateUnit,\n        activeEventName = eventUtils.addNamespace(feedbackEvents.active, UI_FEEDBACK),\n        inactiveEventName = eventUtils.addNamespace(feedbackEvents.inactive, UI_FEEDBACK);\n    eventsEngine.off(that._eventBindingTarget(), activeEventName, feedbackSelector);\n    eventsEngine.off(that._eventBindingTarget(), inactiveEventName, feedbackSelector);\n\n    if (that.option(\"activeStateEnabled\")) {\n      var feedbackActionHandler = function feedbackActionHandler(args) {\n        var $element = $(args.element),\n            value = args.value,\n            dxEvent = args.event;\n\n        that._toggleActiveState($element, value, dxEvent);\n      };\n\n      eventsEngine.on(that._eventBindingTarget(), activeEventName, feedbackSelector, {\n        timeout: that._feedbackShowTimeout\n      }, function (e) {\n        feedbackAction = feedbackAction || new Action(feedbackActionHandler);\n        feedbackAction.execute({\n          element: $(e.currentTarget),\n          value: true,\n          event: e\n        });\n      });\n      eventsEngine.on(that._eventBindingTarget(), inactiveEventName, feedbackSelector, {\n        timeout: that._feedbackHideTimeout\n      }, function (e) {\n        feedbackActionDisabled = feedbackActionDisabled || new Action(feedbackActionHandler, {\n          excludeValidators: [\"disabled\", \"readOnly\"]\n        });\n        feedbackActionDisabled.execute({\n          element: $(e.currentTarget),\n          value: false,\n          event: e\n        });\n      });\n    }\n  },\n  _toggleActiveState: function _toggleActiveState($element, value) {\n    this._toggleHoverClass(!value);\n\n    $element.toggleClass(ACTIVE_STATE_CLASS, value);\n  },\n  _refreshHoveredElement: function _refreshHoveredElement(hoveredElement) {\n    var selector = this._activeStateUnit || this._eventBindingTarget();\n\n    this._forgetHoveredElement();\n\n    this._hoveredElement = hoveredElement.closest(selector);\n\n    this._toggleHoverClass(true);\n  },\n  _forgetHoveredElement: function _forgetHoveredElement() {\n    this._toggleHoverClass(false);\n\n    delete this._hoveredElement;\n  },\n  _toggleHoverClass: function _toggleHoverClass(value) {\n    if (this._hoveredElement) {\n      this._hoveredElement.toggleClass(HOVER_STATE_CLASS, value && this.option(\"hoverStateEnabled\"));\n    }\n  },\n  _toggleDisabledState: function _toggleDisabledState(value) {\n    this.$element().toggleClass(DISABLED_STATE_CLASS, Boolean(value));\n\n    this._toggleHoverClass(!value);\n\n    this.setAria(\"disabled\", value || void 0);\n  },\n  _setWidgetOption: function _setWidgetOption(widgetName, args) {\n    if (!this[widgetName]) {\n      return;\n    }\n\n    if (typeUtils.isPlainObject(args[0])) {\n      each(args[0], function (option, value) {\n        this._setWidgetOption(widgetName, [option, value]);\n      }.bind(this));\n      return;\n    }\n\n    var optionName = args[0];\n    var value = args[1];\n\n    if (1 === args.length) {\n      value = this.option(optionName);\n    }\n\n    var widgetOptionMap = this[widgetName + \"OptionMap\"];\n    this[widgetName].option(widgetOptionMap ? widgetOptionMap(optionName) : optionName, value);\n  },\n  _optionChanged: function _optionChanged(args) {\n    switch (args.name) {\n      case \"disabled\":\n        this._toggleDisabledState(args.value);\n\n        this._refreshFocusState();\n\n        break;\n\n      case \"hint\":\n        this._renderHint();\n\n        break;\n\n      case \"activeStateEnabled\":\n        this._attachFeedbackEvents();\n\n        break;\n\n      case \"hoverStateEnabled\":\n        this._attachHoverEvents();\n\n        break;\n\n      case \"tabIndex\":\n      case \"_keyboardProcessor\":\n      case \"focusStateEnabled\":\n        this._refreshFocusState();\n\n        break;\n\n      case \"onFocusIn\":\n      case \"onFocusOut\":\n        break;\n\n      case \"accessKey\":\n        this._renderAccessKey();\n\n        break;\n\n      case \"visible\":\n        var visible = args.value;\n\n        this._toggleVisibility(visible);\n\n        if (this._isVisibilityChangeSupported()) {\n          this._checkVisibilityChanged(args.value ? \"shown\" : \"hiding\");\n        }\n\n        break;\n\n      case \"onContentReady\":\n        this._initContentReadyAction();\n\n        break;\n\n      default:\n        this.callBase(args);\n    }\n  },\n  _isVisible: function _isVisible() {\n    return this.callBase() && this.option(\"visible\");\n  },\n  beginUpdate: function beginUpdate() {\n    this._ready(false);\n\n    this.callBase();\n  },\n  endUpdate: function endUpdate() {\n    this.callBase();\n\n    if (this._initialized) {\n      this._ready(true);\n    }\n  },\n  _ready: function _ready(value) {\n    if (0 === arguments.length) {\n      return this._isReady;\n    }\n\n    this._isReady = value;\n  },\n  setAria: function setAria() {\n    var setAttribute = function setAttribute(option) {\n      var attrName = \"role\" === option.name || \"id\" === option.name ? option.name : \"aria-\" + option.name,\n          attrValue = option.value;\n\n      if (null === attrValue || void 0 === attrValue) {\n        attrValue = void 0;\n      } else {\n        attrValue = attrValue.toString();\n      }\n\n      domUtils.toggleAttr(option.target, attrName, attrValue);\n    };\n\n    if (!typeUtils.isPlainObject(arguments[0])) {\n      setAttribute({\n        name: arguments[0],\n        value: arguments[1],\n        target: arguments[2] || this._getAriaTarget()\n      });\n    } else {\n      var $target = arguments[1] || this._getAriaTarget();\n\n      each(arguments[0], function (key, value) {\n        setAttribute({\n          name: key,\n          value: value,\n          target: $target\n        });\n      });\n    }\n  },\n  isReady: function isReady() {\n    return this._ready();\n  },\n  repaint: function repaint() {\n    this._refresh();\n  },\n  focus: function focus() {\n    eventsEngine.trigger(this._focusTarget(), \"focus\");\n  },\n  registerKeyHandler: function registerKeyHandler(key, handler) {\n    var currentKeys = this._supportedKeys(),\n        addingKeys = {};\n\n    addingKeys[key] = handler;\n\n    this._supportedKeys = function () {\n      return extend(currentKeys, addingKeys);\n    };\n  }\n});\nmodule.exports = Widget;","map":null,"metadata":{},"sourceType":"script"}