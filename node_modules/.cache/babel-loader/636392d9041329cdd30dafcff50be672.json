{"ast":null,"code":"/**\r\n * DevExtreme (ui/scroll_view/ui.scrollable.simulated.js)\r\n * Version: 18.2.8\r\n * Build date: Tue Apr 23 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar $ = require(\"../../core/renderer\"),\n    domAdapter = require(\"../../core/dom_adapter\"),\n    eventsEngine = require(\"../../events/core/events_engine\"),\n    math = Math,\n    titleize = require(\"../../core/utils/inflector\").titleize,\n    extend = require(\"../../core/utils/extend\").extend,\n    windowUtils = require(\"../../core/utils/window\"),\n    iteratorUtils = require(\"../../core/utils/iterator\"),\n    isDefined = require(\"../../core/utils/type\").isDefined,\n    translator = require(\"../../animation/translator\"),\n    Class = require(\"../../core/class\"),\n    Animator = require(\"./animator\"),\n    devices = require(\"../../core/devices\"),\n    eventUtils = require(\"../../events/utils\"),\n    commonUtils = require(\"../../core/utils/common\"),\n    Scrollbar = require(\"./ui.scrollbar\"),\n    deferredUtils = require(\"../../core/utils/deferred\"),\n    when = deferredUtils.when,\n    Deferred = deferredUtils.Deferred;\n\nvar realDevice = devices.real;\nvar isSluggishPlatform = \"win\" === realDevice.platform || \"android\" === realDevice.platform;\nvar SCROLLABLE_SIMULATED = \"dxSimulatedScrollable\",\n    SCROLLABLE_STRATEGY = \"dxScrollableStrategy\",\n    SCROLLABLE_SIMULATED_CURSOR = SCROLLABLE_SIMULATED + \"Cursor\",\n    SCROLLABLE_SIMULATED_KEYBOARD = SCROLLABLE_SIMULATED + \"Keyboard\",\n    SCROLLABLE_SIMULATED_CLASS = \"dx-scrollable-simulated\",\n    SCROLLABLE_SCROLLBARS_HIDDEN = \"dx-scrollable-scrollbars-hidden\",\n    SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE = \"dx-scrollable-scrollbars-alwaysvisible\",\n    SCROLLABLE_SCROLLBAR_CLASS = \"dx-scrollable-scrollbar\",\n    VERTICAL = \"vertical\",\n    HORIZONTAL = \"horizontal\",\n    ACCELERATION = isSluggishPlatform ? .95 : .92,\n    OUT_BOUNDS_ACCELERATION = .5,\n    MIN_VELOCITY_LIMIT = 1,\n    FRAME_DURATION = math.round(1e3 / 60),\n    SCROLL_LINE_HEIGHT = 20,\n    BOUNCE_MIN_VELOCITY_LIMIT = MIN_VELOCITY_LIMIT / 5,\n    BOUNCE_DURATION = isSluggishPlatform ? 300 : 400,\n    BOUNCE_FRAMES = BOUNCE_DURATION / FRAME_DURATION,\n    BOUNCE_ACCELERATION_SUM = (1 - math.pow(ACCELERATION, BOUNCE_FRAMES)) / (1 - ACCELERATION);\nvar KEY_CODES = {\n  PAGE_UP: \"pageUp\",\n  PAGE_DOWN: \"pageDown\",\n  END: \"end\",\n  HOME: \"home\",\n  LEFT: \"leftArrow\",\n  UP: \"upArrow\",\n  RIGHT: \"rightArrow\",\n  DOWN: \"downArrow\"\n};\nvar InertiaAnimator = Animator.inherit({\n  ctor: function ctor(scroller) {\n    this.callBase();\n    this.scroller = scroller;\n  },\n  VELOCITY_LIMIT: MIN_VELOCITY_LIMIT,\n  _isFinished: function _isFinished() {\n    return math.abs(this.scroller._velocity) <= this.VELOCITY_LIMIT;\n  },\n  _step: function _step() {\n    this.scroller._scrollStep(this.scroller._velocity);\n\n    this.scroller._velocity *= this._acceleration();\n  },\n  _acceleration: function _acceleration() {\n    return this.scroller._inBounds() ? ACCELERATION : OUT_BOUNDS_ACCELERATION;\n  },\n  _complete: function _complete() {\n    this.scroller._scrollComplete();\n  },\n  _stop: function _stop() {\n    this.scroller._stopComplete();\n  }\n});\nvar BounceAnimator = InertiaAnimator.inherit({\n  VELOCITY_LIMIT: BOUNCE_MIN_VELOCITY_LIMIT,\n  _isFinished: function _isFinished() {\n    return this.scroller._crossBoundOnNextStep() || this.callBase();\n  },\n  _acceleration: function _acceleration() {\n    return ACCELERATION;\n  },\n  _complete: function _complete() {\n    this.scroller._move(this.scroller._bounceLocation);\n\n    this.callBase();\n  }\n});\n\nvar isWheelEvent = function isWheelEvent(e) {\n  return \"dxmousewheel\" === e.type;\n};\n\nvar Scroller = Class.inherit({\n  ctor: function ctor(options) {\n    this._initOptions(options);\n\n    this._initAnimators();\n\n    this._initScrollbar();\n  },\n  _initOptions: function _initOptions(options) {\n    this._location = 0;\n    this._topReached = false;\n    this._bottomReached = false;\n    this._axis = options.direction === HORIZONTAL ? \"x\" : \"y\";\n    this._prop = options.direction === HORIZONTAL ? \"left\" : \"top\";\n    this._dimension = options.direction === HORIZONTAL ? \"width\" : \"height\";\n    this._scrollProp = options.direction === HORIZONTAL ? \"scrollLeft\" : \"scrollTop\";\n    iteratorUtils.each(options, function (optionName, optionValue) {\n      this[\"_\" + optionName] = optionValue;\n    }.bind(this));\n  },\n  _initAnimators: function _initAnimators() {\n    this._inertiaAnimator = new InertiaAnimator(this);\n    this._bounceAnimator = new BounceAnimator(this);\n  },\n  _initScrollbar: function _initScrollbar() {\n    this._scrollbar = new Scrollbar($(\"<div>\").appendTo(this._$container), {\n      direction: this._direction,\n      visible: this._scrollByThumb,\n      visibilityMode: this._visibilityModeNormalize(this._scrollbarVisible),\n      expandable: this._scrollByThumb\n    });\n    this._$scrollbar = this._scrollbar.$element();\n  },\n  _visibilityModeNormalize: function _visibilityModeNormalize(mode) {\n    return true === mode ? \"onScroll\" : false === mode ? \"never\" : mode;\n  },\n  _scrollStep: function _scrollStep(delta) {\n    var prevLocation = this._location;\n    this._location += delta;\n\n    this._suppressBounce();\n\n    this._move();\n\n    if (Math.abs(prevLocation - this._location) < 1) {\n      return;\n    }\n\n    eventsEngine.triggerHandler(this._$container, {\n      type: \"scroll\"\n    });\n  },\n  _suppressBounce: function _suppressBounce() {\n    if (this._bounceEnabled || this._inBounds(this._location)) {\n      return;\n    }\n\n    this._velocity = 0;\n    this._location = this._boundLocation();\n  },\n  _boundLocation: function _boundLocation(location) {\n    location = void 0 !== location ? location : this._location;\n    return math.max(math.min(location, this._maxOffset), this._minOffset);\n  },\n  _move: function _move(location) {\n    this._location = void 0 !== location ? location * this._getScaleRatio() : this._location;\n\n    this._moveContent();\n\n    this._moveScrollbar();\n  },\n  _moveContent: function _moveContent() {\n    var location = this._location;\n\n    this._$container[this._scrollProp](-location / this._getScaleRatio());\n\n    this._moveContentByTranslator(location);\n  },\n  _getScaleRatio: function _getScaleRatio() {\n    if (windowUtils.hasWindow() && !this._scaleRatio) {\n      var element = this._$element.get(0),\n          realDimension = this._getRealDimension(element, this._dimension),\n          baseDimension = this._getBaseDimension(element, this._dimension);\n\n      this._scaleRatio = realDimension / baseDimension;\n    }\n\n    return this._scaleRatio || 1;\n  },\n  _getRealDimension: function _getRealDimension(element, dimension) {\n    return math.round(element.getBoundingClientRect()[dimension]);\n  },\n  _getBaseDimension: function _getBaseDimension(element, dimension) {\n    var dimensionName = \"offset\" + titleize(dimension);\n    return element[dimensionName];\n  },\n  _moveContentByTranslator: function _moveContentByTranslator(location) {\n    var translateOffset,\n        minOffset = -this._maxScrollPropValue;\n\n    if (location > 0) {\n      translateOffset = location;\n    } else {\n      if (location <= minOffset) {\n        translateOffset = location - minOffset;\n      } else {\n        translateOffset = location % 1;\n      }\n    }\n\n    if (this._translateOffset === translateOffset) {\n      return;\n    }\n\n    var targetLocation = {};\n    targetLocation[this._prop] = translateOffset;\n    this._translateOffset = translateOffset;\n\n    if (0 === translateOffset) {\n      translator.resetPosition(this._$content);\n      return;\n    }\n\n    translator.move(this._$content, targetLocation);\n  },\n  _moveScrollbar: function _moveScrollbar() {\n    this._scrollbar.moveTo(this._location);\n  },\n  _scrollComplete: function _scrollComplete() {\n    if (this._inBounds()) {\n      this._hideScrollbar();\n\n      if (this._completeDeferred) {\n        this._completeDeferred.resolve();\n      }\n    }\n\n    this._scrollToBounds();\n  },\n  _scrollToBounds: function _scrollToBounds() {\n    if (this._inBounds()) {\n      return;\n    }\n\n    this._bounceAction();\n\n    this._setupBounce();\n\n    this._bounceAnimator.start();\n  },\n  _setupBounce: function _setupBounce() {\n    var boundLocation = this._bounceLocation = this._boundLocation(),\n        bounceDistance = boundLocation - this._location;\n\n    this._velocity = bounceDistance / BOUNCE_ACCELERATION_SUM;\n  },\n  _inBounds: function _inBounds(location) {\n    location = void 0 !== location ? location : this._location;\n    return this._boundLocation(location) === location;\n  },\n  _crossBoundOnNextStep: function _crossBoundOnNextStep() {\n    var location = this._location,\n        nextLocation = location + this._velocity;\n    return location < this._minOffset && nextLocation >= this._minOffset || location > this._maxOffset && nextLocation <= this._maxOffset;\n  },\n  _initHandler: function _initHandler(e) {\n    this._stopDeferred = new Deferred();\n\n    this._stopScrolling();\n\n    this._prepareThumbScrolling(e);\n\n    return this._stopDeferred.promise();\n  },\n  _stopScrolling: commonUtils.deferRenderer(function () {\n    this._hideScrollbar();\n\n    this._inertiaAnimator.stop();\n\n    this._bounceAnimator.stop();\n  }),\n  _prepareThumbScrolling: function _prepareThumbScrolling(e) {\n    if (isWheelEvent(e.originalEvent)) {\n      return;\n    }\n\n    var $target = $(e.originalEvent.target);\n\n    var scrollbarClicked = this._isScrollbar($target);\n\n    if (scrollbarClicked) {\n      this._moveToMouseLocation(e);\n    }\n\n    this._thumbScrolling = scrollbarClicked || this._isThumb($target);\n    this._crossThumbScrolling = !this._thumbScrolling && this._isAnyThumbScrolling($target);\n\n    if (this._thumbScrolling) {\n      this._scrollbar.feedbackOn();\n    }\n  },\n  _isThumbScrollingHandler: function _isThumbScrollingHandler($target) {\n    return this._isThumb($target);\n  },\n  _moveToMouseLocation: function _moveToMouseLocation(e) {\n    var mouseLocation = e[\"page\" + this._axis.toUpperCase()] - this._$element.offset()[this._prop];\n\n    var location = this._location + mouseLocation / this._containerToContentRatio() - this._$container.height() / 2;\n\n    this._scrollStep(-Math.round(location));\n  },\n  _stopComplete: function _stopComplete() {\n    if (this._stopDeferred) {\n      this._stopDeferred.resolve();\n    }\n  },\n  _startHandler: function _startHandler() {\n    this._showScrollbar();\n  },\n  _moveHandler: function _moveHandler(delta) {\n    if (this._crossThumbScrolling) {\n      return;\n    }\n\n    if (this._thumbScrolling) {\n      delta[this._axis] = -Math.round(delta[this._axis] / this._containerToContentRatio());\n    }\n\n    this._scrollBy(delta);\n  },\n  _scrollBy: function _scrollBy(delta) {\n    delta = delta[this._axis];\n\n    if (!this._inBounds()) {\n      delta *= OUT_BOUNDS_ACCELERATION;\n    }\n\n    this._scrollStep(delta);\n  },\n  _scrollByHandler: function _scrollByHandler(delta) {\n    this._scrollBy(delta);\n\n    this._scrollComplete();\n  },\n  _containerToContentRatio: function _containerToContentRatio() {\n    return this._scrollbar.containerToContentRatio();\n  },\n  _endHandler: function _endHandler(velocity) {\n    this._completeDeferred = new Deferred();\n    this._velocity = velocity[this._axis];\n\n    this._inertiaHandler();\n\n    this._resetThumbScrolling();\n\n    return this._completeDeferred.promise();\n  },\n  _inertiaHandler: function _inertiaHandler() {\n    this._suppressInertia();\n\n    this._inertiaAnimator.start();\n  },\n  _suppressInertia: function _suppressInertia() {\n    if (!this._inertiaEnabled || this._thumbScrolling) {\n      this._velocity = 0;\n    }\n  },\n  _resetThumbScrolling: function _resetThumbScrolling() {\n    this._thumbScrolling = false;\n    this._crossThumbScrolling = false;\n  },\n  _stopHandler: function _stopHandler() {\n    if (this._thumbScrolling) {\n      this._scrollComplete();\n    }\n\n    this._resetThumbScrolling();\n\n    this._scrollToBounds();\n  },\n  _disposeHandler: function _disposeHandler() {\n    this._stopScrolling();\n\n    this._$scrollbar.remove();\n  },\n  _updateHandler: function _updateHandler() {\n    this._update();\n\n    this._moveToBounds();\n  },\n  _update: function _update() {\n    var that = this;\n\n    that._stopScrolling();\n\n    return commonUtils.deferUpdate(function () {\n      that._resetScaleRatio();\n\n      that._updateLocation();\n\n      that._updateBounds();\n\n      that._updateScrollbar();\n\n      commonUtils.deferRender(function () {\n        that._moveScrollbar();\n\n        that._scrollbar.update();\n      });\n    });\n  },\n  _resetScaleRatio: function _resetScaleRatio() {\n    this._scaleRatio = null;\n  },\n  _updateLocation: function _updateLocation() {\n    this._location = (translator.locate(this._$content)[this._prop] - this._$container[this._scrollProp]()) * this._getScaleRatio();\n  },\n  _updateBounds: function _updateBounds() {\n    this._maxOffset = Math.round(this._getMaxOffset());\n    this._minOffset = Math.round(this._getMinOffset());\n  },\n  _getMaxOffset: function _getMaxOffset() {\n    return 0;\n  },\n  _getMinOffset: function _getMinOffset() {\n    this._maxScrollPropValue = math.max(this._contentSize() - this._containerSize(), 0);\n    return -this._maxScrollPropValue;\n  },\n  _updateScrollbar: commonUtils.deferUpdater(function () {\n    var that = this,\n        containerSize = that._containerSize(),\n        contentSize = that._contentSize();\n\n    commonUtils.deferRender(function () {\n      that._scrollbar.option({\n        containerSize: containerSize,\n        contentSize: contentSize,\n        scaleRatio: that._getScaleRatio()\n      });\n    });\n  }),\n  _moveToBounds: commonUtils.deferRenderer(commonUtils.deferUpdater(commonUtils.deferRenderer(function () {\n    var location = this._boundLocation();\n\n    var locationChanged = location !== this._location;\n    this._location = location;\n\n    this._move();\n\n    if (locationChanged) {\n      this._scrollAction();\n    }\n  }))),\n  _createActionsHandler: function _createActionsHandler(actions) {\n    this._scrollAction = actions.scroll;\n    this._bounceAction = actions.bounce;\n  },\n  _showScrollbar: function _showScrollbar() {\n    this._scrollbar.option(\"visible\", true);\n  },\n  _hideScrollbar: function _hideScrollbar() {\n    this._scrollbar.option(\"visible\", false);\n  },\n  _containerSize: function _containerSize() {\n    return this._getRealDimension(this._$container.get(0), this._dimension);\n  },\n  _contentSize: function _contentSize() {\n    var isOverflowHidden = \"hidden\" === this._$content.css(\"overflow\" + this._axis.toUpperCase()),\n        contentSize = this._getRealDimension(this._$content.get(0), this._dimension);\n\n    if (!isOverflowHidden) {\n      var containerScrollSize = this._$content[0][\"scroll\" + titleize(this._dimension)] * this._getScaleRatio();\n\n      contentSize = math.max(containerScrollSize, contentSize);\n    }\n\n    return contentSize;\n  },\n  _validateEvent: function _validateEvent(e) {\n    var $target = $(e.originalEvent.target);\n    return this._isThumb($target) || this._isScrollbar($target) || this._isContent($target);\n  },\n  _isThumb: function _isThumb($element) {\n    return this._scrollByThumb && this._scrollbar.isThumb($element);\n  },\n  _isScrollbar: function _isScrollbar($element) {\n    return this._scrollByThumb && $element && $element.is(this._$scrollbar);\n  },\n  _isContent: function _isContent($element) {\n    return this._scrollByContent && !!$element.closest(this._$element).length;\n  },\n  _reachedMin: function _reachedMin() {\n    return this._location <= this._minOffset;\n  },\n  _reachedMax: function _reachedMax() {\n    return this._location >= this._maxOffset;\n  },\n  _cursorEnterHandler: function _cursorEnterHandler() {\n    this._scrollbar.cursorEnter();\n  },\n  _cursorLeaveHandler: function _cursorLeaveHandler() {\n    this._scrollbar.cursorLeave();\n  },\n  dispose: commonUtils.noop\n});\nvar hoveredScrollable, activeScrollable;\nvar SimulatedStrategy = Class.inherit({\n  ctor: function ctor(scrollable) {\n    this._init(scrollable);\n  },\n  _init: function _init(scrollable) {\n    this._component = scrollable;\n    this._$element = scrollable.$element();\n    this._$container = scrollable._$container;\n    this._$wrapper = scrollable._$wrapper;\n    this._$content = scrollable._$content;\n    this.option = scrollable.option.bind(scrollable);\n    this._createActionByOption = scrollable._createActionByOption.bind(scrollable);\n    this._isLocked = scrollable._isLocked.bind(scrollable);\n    this._isDirection = scrollable._isDirection.bind(scrollable);\n    this._allowedDirection = scrollable._allowedDirection.bind(scrollable);\n  },\n  render: function render() {\n    this._$element.addClass(SCROLLABLE_SIMULATED_CLASS);\n\n    this._createScrollers();\n\n    if (this.option(\"useKeyboard\")) {\n      this._$container.prop(\"tabIndex\", 0);\n    }\n\n    this._attachKeyboardHandler();\n\n    this._attachCursorHandlers();\n  },\n  _createScrollers: function _createScrollers() {\n    this._scrollers = {};\n\n    if (this._isDirection(HORIZONTAL)) {\n      this._createScroller(HORIZONTAL);\n    }\n\n    if (this._isDirection(VERTICAL)) {\n      this._createScroller(VERTICAL);\n    }\n\n    this._$element.toggleClass(SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE, \"always\" === this.option(\"showScrollbar\"));\n\n    this._$element.toggleClass(SCROLLABLE_SCROLLBARS_HIDDEN, !this.option(\"showScrollbar\"));\n  },\n  _createScroller: function _createScroller(direction) {\n    this._scrollers[direction] = new Scroller(this._scrollerOptions(direction));\n  },\n  _scrollerOptions: function _scrollerOptions(direction) {\n    return {\n      direction: direction,\n      $content: this._$content,\n      $container: this._$container,\n      $wrapper: this._$wrapper,\n      $element: this._$element,\n      scrollByContent: this.option(\"scrollByContent\"),\n      scrollByThumb: this.option(\"scrollByThumb\"),\n      scrollbarVisible: this.option(\"showScrollbar\"),\n      bounceEnabled: this.option(\"bounceEnabled\"),\n      inertiaEnabled: this.option(\"inertiaEnabled\"),\n      isAnyThumbScrolling: this._isAnyThumbScrolling.bind(this)\n    };\n  },\n  _applyScaleRatio: function _applyScaleRatio(targetLocation) {\n    for (var direction in this._scrollers) {\n      var prop = this._getPropByDirection(direction);\n\n      if (isDefined(targetLocation[prop])) {\n        var scroller = this._scrollers[direction];\n        targetLocation[prop] *= scroller._getScaleRatio();\n      }\n    }\n\n    return targetLocation;\n  },\n  _isAnyThumbScrolling: function _isAnyThumbScrolling($target) {\n    var result = false;\n\n    this._eventHandler(\"isThumbScrolling\", $target).done(function (isThumbScrollingVertical, isThumbScrollingHorizontal) {\n      result = isThumbScrollingVertical || isThumbScrollingHorizontal;\n    });\n\n    return result;\n  },\n  handleInit: function handleInit(e) {\n    this._suppressDirections(e);\n\n    this._eventForUserAction = e;\n\n    this._eventHandler(\"init\", e).done(this._stopAction);\n  },\n  _suppressDirections: function _suppressDirections(e) {\n    if (isWheelEvent(e.originalEvent)) {\n      this._prepareDirections(true);\n\n      return;\n    }\n\n    this._prepareDirections();\n\n    this._eachScroller(function (scroller, direction) {\n      var isValid = scroller._validateEvent(e);\n\n      this._validDirections[direction] = isValid;\n    });\n  },\n  _prepareDirections: function _prepareDirections(value) {\n    value = value || false;\n    this._validDirections = {};\n    this._validDirections[HORIZONTAL] = value;\n    this._validDirections[VERTICAL] = value;\n  },\n  _eachScroller: function _eachScroller(callback) {\n    callback = callback.bind(this);\n    iteratorUtils.each(this._scrollers, function (direction, scroller) {\n      callback(scroller, direction);\n    });\n  },\n  handleStart: function handleStart(e) {\n    this._eventForUserAction = e;\n\n    this._eventHandler(\"start\").done(this._startAction);\n  },\n  _saveActive: function _saveActive() {\n    activeScrollable = this;\n  },\n  _resetActive: function _resetActive() {\n    if (activeScrollable === this) {\n      activeScrollable = null;\n    }\n  },\n  handleMove: function handleMove(e) {\n    if (this._isLocked()) {\n      e.cancel = true;\n\n      this._resetActive();\n\n      return;\n    }\n\n    this._saveActive();\n\n    e.preventDefault && e.preventDefault();\n\n    this._adjustDistance(e.delta);\n\n    this._eventForUserAction = e;\n\n    this._eventHandler(\"move\", e.delta);\n  },\n  _adjustDistance: function _adjustDistance(distance) {\n    distance.x *= this._validDirections[HORIZONTAL];\n    distance.y *= this._validDirections[VERTICAL];\n  },\n  handleEnd: function handleEnd(e) {\n    this._resetActive();\n\n    this._refreshCursorState(e.originalEvent && e.originalEvent.target);\n\n    this._adjustDistance(e.velocity);\n\n    this._eventForUserAction = e;\n    return this._eventHandler(\"end\", e.velocity).done(this._endAction);\n  },\n  handleCancel: function handleCancel(e) {\n    this._resetActive();\n\n    this._eventForUserAction = e;\n    return this._eventHandler(\"end\", {\n      x: 0,\n      y: 0\n    });\n  },\n  handleStop: function handleStop() {\n    this._resetActive();\n\n    this._eventHandler(\"stop\");\n  },\n  handleScroll: function handleScroll() {\n    this._scrollAction();\n  },\n  _attachKeyboardHandler: function _attachKeyboardHandler() {\n    eventsEngine.off(this._$element, \".\" + SCROLLABLE_SIMULATED_KEYBOARD);\n\n    if (!this.option(\"disabled\") && this.option(\"useKeyboard\")) {\n      eventsEngine.on(this._$element, eventUtils.addNamespace(\"keydown\", SCROLLABLE_SIMULATED_KEYBOARD), this._keyDownHandler.bind(this));\n    }\n  },\n  _keyDownHandler: function _keyDownHandler(e) {\n    if (!this._$container.is(domAdapter.getActiveElement())) {\n      return;\n    }\n\n    var handled = true;\n\n    switch (eventUtils.normalizeKeyName(e)) {\n      case KEY_CODES.DOWN:\n        this._scrollByLine({\n          y: 1\n        });\n\n        break;\n\n      case KEY_CODES.UP:\n        this._scrollByLine({\n          y: -1\n        });\n\n        break;\n\n      case KEY_CODES.RIGHT:\n        this._scrollByLine({\n          x: 1\n        });\n\n        break;\n\n      case KEY_CODES.LEFT:\n        this._scrollByLine({\n          x: -1\n        });\n\n        break;\n\n      case KEY_CODES.PAGE_DOWN:\n        this._scrollByPage(1);\n\n        break;\n\n      case KEY_CODES.PAGE_UP:\n        this._scrollByPage(-1);\n\n        break;\n\n      case KEY_CODES.HOME:\n        this._scrollToHome();\n\n        break;\n\n      case KEY_CODES.END:\n        this._scrollToEnd();\n\n        break;\n\n      default:\n        handled = false;\n    }\n\n    if (handled) {\n      e.stopPropagation();\n      e.preventDefault();\n    }\n  },\n  _scrollByLine: function _scrollByLine(lines) {\n    this.scrollBy({\n      top: (lines.y || 0) * -SCROLL_LINE_HEIGHT,\n      left: (lines.x || 0) * -SCROLL_LINE_HEIGHT\n    });\n  },\n  _scrollByPage: function _scrollByPage(page) {\n    var prop = this._wheelProp(),\n        dimension = this._dimensionByProp(prop);\n\n    var distance = {};\n    distance[prop] = page * -this._$container[dimension]();\n    this.scrollBy(distance);\n  },\n  _dimensionByProp: function _dimensionByProp(prop) {\n    return \"left\" === prop ? \"width\" : \"height\";\n  },\n  _getPropByDirection: function _getPropByDirection(direction) {\n    return direction === HORIZONTAL ? \"left\" : \"top\";\n  },\n  _scrollToHome: function _scrollToHome() {\n    var prop = this._wheelProp();\n\n    var distance = {};\n    distance[prop] = 0;\n\n    this._component.scrollTo(distance);\n  },\n  _scrollToEnd: function _scrollToEnd() {\n    var prop = this._wheelProp(),\n        dimension = this._dimensionByProp(prop);\n\n    var distance = {};\n    distance[prop] = this._$content[dimension]() - this._$container[dimension]();\n\n    this._component.scrollTo(distance);\n  },\n  createActions: function createActions() {\n    this._startAction = this._createActionHandler(\"onStart\");\n    this._stopAction = this._createActionHandler(\"onStop\");\n    this._endAction = this._createActionHandler(\"onEnd\");\n    this._updateAction = this._createActionHandler(\"onUpdated\");\n\n    this._createScrollerActions();\n  },\n  _createScrollerActions: function _createScrollerActions() {\n    this._scrollAction = this._createActionHandler(\"onScroll\");\n    this._bounceAction = this._createActionHandler(\"onBounce\");\n\n    this._eventHandler(\"createActions\", {\n      scroll: this._scrollAction,\n      bounce: this._bounceAction\n    });\n  },\n  _createActionHandler: function _createActionHandler(optionName) {\n    var that = this,\n        actionHandler = that._createActionByOption(optionName);\n\n    return function () {\n      actionHandler(extend(that._createActionArgs(), arguments));\n    };\n  },\n  _createActionArgs: function _createActionArgs() {\n    var scrollerX = this._scrollers[HORIZONTAL],\n        scrollerY = this._scrollers[VERTICAL];\n    var location = this.location();\n    this._scrollOffset = {\n      top: scrollerY && -location.top,\n      left: scrollerX && -location.left\n    };\n    return {\n      event: this._eventForUserAction,\n      scrollOffset: this._scrollOffset,\n      reachedLeft: scrollerX && scrollerX._reachedMax(),\n      reachedRight: scrollerX && scrollerX._reachedMin(),\n      reachedTop: scrollerY && scrollerY._reachedMax(),\n      reachedBottom: scrollerY && scrollerY._reachedMin()\n    };\n  },\n  _eventHandler: function _eventHandler(eventName) {\n    var args = [].slice.call(arguments).slice(1),\n        deferreds = iteratorUtils.map(this._scrollers, function (scroller) {\n      return scroller[\"_\" + eventName + \"Handler\"].apply(scroller, args);\n    });\n    return when.apply($, deferreds).promise();\n  },\n  location: function location() {\n    var location = translator.locate(this._$content);\n    location.top -= this._$container.scrollTop();\n    location.left -= this._$container.scrollLeft();\n    return location;\n  },\n  disabledChanged: function disabledChanged() {\n    this._attachCursorHandlers();\n  },\n  _attachCursorHandlers: function _attachCursorHandlers() {\n    eventsEngine.off(this._$element, \".\" + SCROLLABLE_SIMULATED_CURSOR);\n\n    if (!this.option(\"disabled\") && this._isHoverMode()) {\n      eventsEngine.on(this._$element, eventUtils.addNamespace(\"mouseenter\", SCROLLABLE_SIMULATED_CURSOR), this._cursorEnterHandler.bind(this));\n      eventsEngine.on(this._$element, eventUtils.addNamespace(\"mouseleave\", SCROLLABLE_SIMULATED_CURSOR), this._cursorLeaveHandler.bind(this));\n    }\n  },\n  _isHoverMode: function _isHoverMode() {\n    return \"onHover\" === this.option(\"showScrollbar\");\n  },\n  _cursorEnterHandler: function _cursorEnterHandler(e) {\n    e = e || {};\n    e.originalEvent = e.originalEvent || {};\n\n    if (activeScrollable || e.originalEvent._hoverHandled) {\n      return;\n    }\n\n    if (hoveredScrollable) {\n      hoveredScrollable._cursorLeaveHandler();\n    }\n\n    hoveredScrollable = this;\n\n    this._eventHandler(\"cursorEnter\");\n\n    e.originalEvent._hoverHandled = true;\n  },\n  _cursorLeaveHandler: function _cursorLeaveHandler(e) {\n    if (hoveredScrollable !== this || activeScrollable === hoveredScrollable) {\n      return;\n    }\n\n    this._eventHandler(\"cursorLeave\");\n\n    hoveredScrollable = null;\n\n    this._refreshCursorState(e && e.relatedTarget);\n  },\n  _refreshCursorState: function _refreshCursorState(target) {\n    if (!this._isHoverMode() && (!target || activeScrollable)) {\n      return;\n    }\n\n    var $target = $(target);\n    var $scrollable = $target.closest(\".\" + SCROLLABLE_SIMULATED_CLASS + \":not(.dx-state-disabled)\");\n    var targetScrollable = $scrollable.length && $scrollable.data(SCROLLABLE_STRATEGY);\n\n    if (hoveredScrollable && hoveredScrollable !== targetScrollable) {\n      hoveredScrollable._cursorLeaveHandler();\n    }\n\n    if (targetScrollable) {\n      targetScrollable._cursorEnterHandler();\n    }\n  },\n  update: function update() {\n    var that = this;\n\n    var result = this._eventHandler(\"update\").done(this._updateAction);\n\n    return when(result, commonUtils.deferUpdate(function () {\n      var allowedDirections = that._allowedDirections();\n\n      commonUtils.deferRender(function () {\n        var touchDirection = allowedDirections.vertical ? \"pan-x\" : \"\";\n        touchDirection = allowedDirections.horizontal ? \"pan-y\" : touchDirection;\n        touchDirection = allowedDirections.vertical && allowedDirections.horizontal ? \"none\" : touchDirection;\n\n        that._$container.css(\"touchAction\", touchDirection);\n      });\n      return when().promise();\n    }));\n  },\n  _allowedDirections: function _allowedDirections() {\n    var bounceEnabled = this.option(\"bounceEnabled\"),\n        verticalScroller = this._scrollers[VERTICAL],\n        horizontalScroller = this._scrollers[HORIZONTAL];\n    return {\n      vertical: verticalScroller && (verticalScroller._minOffset < 0 || bounceEnabled),\n      horizontal: horizontalScroller && (horizontalScroller._minOffset < 0 || bounceEnabled)\n    };\n  },\n  updateBounds: function updateBounds() {\n    this._scrollers[HORIZONTAL] && this._scrollers[HORIZONTAL]._updateBounds();\n  },\n  scrollBy: function scrollBy(distance) {\n    var verticalScroller = this._scrollers[VERTICAL],\n        horizontalScroller = this._scrollers[HORIZONTAL];\n\n    if (verticalScroller) {\n      distance.top = verticalScroller._boundLocation(distance.top + verticalScroller._location) - verticalScroller._location;\n    }\n\n    if (horizontalScroller) {\n      distance.left = horizontalScroller._boundLocation(distance.left + horizontalScroller._location) - horizontalScroller._location;\n    }\n\n    this._prepareDirections(true);\n\n    this._startAction();\n\n    this._eventHandler(\"scrollBy\", {\n      x: distance.left,\n      y: distance.top\n    });\n\n    this._endAction();\n  },\n  validate: function validate(e) {\n    if (this.option(\"disabled\")) {\n      return false;\n    }\n\n    if (this.option(\"bounceEnabled\")) {\n      return true;\n    }\n\n    return isWheelEvent(e) ? this._validateWheel(e) : this._validateMove(e);\n  },\n  _validateWheel: function _validateWheel(e) {\n    var scroller = this._scrollers[this._wheelDirection(e)];\n\n    var reachedMin = scroller._reachedMin();\n\n    var reachedMax = scroller._reachedMax();\n\n    var contentGreaterThanContainer = !reachedMin || !reachedMax;\n    var locatedNotAtBound = !reachedMin && !reachedMax;\n    var scrollFromMin = reachedMin && e.delta > 0;\n    var scrollFromMax = reachedMax && e.delta < 0;\n    return contentGreaterThanContainer && (locatedNotAtBound || scrollFromMin || scrollFromMax);\n  },\n  _validateMove: function _validateMove(e) {\n    if (!this.option(\"scrollByContent\") && !$(e.target).closest(\".\" + SCROLLABLE_SCROLLBAR_CLASS).length) {\n      return false;\n    }\n\n    return this._allowedDirection();\n  },\n  getDirection: function getDirection(e) {\n    return isWheelEvent(e) ? this._wheelDirection(e) : this._allowedDirection();\n  },\n  _wheelProp: function _wheelProp() {\n    return this._wheelDirection() === HORIZONTAL ? \"left\" : \"top\";\n  },\n  _wheelDirection: function _wheelDirection(e) {\n    switch (this.option(\"direction\")) {\n      case HORIZONTAL:\n        return HORIZONTAL;\n\n      case VERTICAL:\n        return VERTICAL;\n\n      default:\n        return e && e.shiftKey ? HORIZONTAL : VERTICAL;\n    }\n  },\n  verticalOffset: function verticalOffset() {\n    return 0;\n  },\n  dispose: function dispose() {\n    this._resetActive();\n\n    if (hoveredScrollable === this) {\n      hoveredScrollable = null;\n    }\n\n    this._eventHandler(\"dispose\");\n\n    this._detachEventHandlers();\n\n    this._$element.removeClass(SCROLLABLE_SIMULATED_CLASS);\n\n    this._eventForUserAction = null;\n    clearTimeout(this._gestureEndTimer);\n  },\n  _detachEventHandlers: function _detachEventHandlers() {\n    eventsEngine.off(this._$element, \".\" + SCROLLABLE_SIMULATED_CURSOR);\n    eventsEngine.off(this._$container, \".\" + SCROLLABLE_SIMULATED_KEYBOARD);\n  }\n});\nexports.SimulatedStrategy = SimulatedStrategy;\nexports.Scroller = Scroller;","map":null,"metadata":{},"sourceType":"script"}