{"ast":null,"code":"/*!\n * devextreme-react\n * Version: 18.2.8\n * Build date: Tue Apr 23 2019\n *\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\n *\n * This software may be modified and distributed under the terms\n * of the MIT license. See the LICENSE file in the root of the project for details.\n *\n * https://github.com/DevExpress/devextreme-react\n */\n\"use strict\";\n\nvar __assign = this && this.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) {\n      if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n  }\n\n  return t;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar react_1 = require(\"react\");\n\nvar helpers_1 = require(\"./helpers\");\n\nvar nested_option_1 = require(\"./nested-option\");\n\nvar widget_config_1 = require(\"./widget-config\");\n\nfunction isEventHanlder(optionName, optionValue) {\n  return optionName.substr(0, 2) === \"on\" && typeof optionValue === \"function\";\n}\n\nvar OptionsManager =\n/** @class */\nfunction () {\n  function OptionsManager(optionValueGetter, templateHost) {\n    this._guards = {};\n    this._nestedOptions = {};\n    this._dirtyOptions = {};\n    this._optionValueGetter = optionValueGetter;\n    this._templateHost = templateHost;\n    this._setOption = this._setOption.bind(this);\n    this._registerNestedOption = this._registerNestedOption.bind(this);\n    this.registerNestedOption = this.registerNestedOption.bind(this);\n    this.handleOptionChange = this.handleOptionChange.bind(this);\n    this.processChangedValues = this.processChangedValues.bind(this);\n  }\n\n  OptionsManager.prototype.resetNestedElements = function () {\n    var _this = this;\n\n    Object.keys(this._nestedOptions).forEach(function (optionName) {\n      _this._nestedOptions[optionName].elementEntries.length = 0;\n    });\n  };\n\n  OptionsManager.prototype.setInstance = function (instance) {\n    this._instance = instance;\n  };\n\n  OptionsManager.prototype.wrapEventHandlers = function (options) {\n    var _this = this;\n\n    Object.keys(options).forEach(function (name) {\n      var value = options[name];\n\n      if (isEventHanlder(name, value)) {\n        options[name] = _this._wrapEventHandler(value);\n      }\n    });\n  };\n\n  OptionsManager.prototype.handleOptionChange = function (e) {\n    var _this = this;\n\n    if (this._updatingProps) {\n      return;\n    }\n\n    var optionValue;\n    var optionName;\n    var nestedOption = this._nestedOptions[e.name];\n\n    if (nestedOption && nestedOption.elementEntries.length > 0) {\n      optionName = e.fullName;\n      var nestedOptionObj = widget_config_1.separateProps(nestedOption.elementEntries[0].element.props, nestedOption.defaults, []).options;\n\n      if (e.name === e.fullName) {\n        Object.keys(nestedOptionObj).forEach(function (key) {\n          return _this.handleOptionChange({\n            name: e.name,\n            fullName: e.fullName + \".\" + key,\n            value: e.value[key]\n          });\n        });\n        return;\n      }\n\n      if (nestedOption.isCollectionItem) {\n        return;\n      }\n\n      optionValue = helpers_1.getNestedValue(nestedOptionObj, e.fullName.split(\".\").slice(1));\n    } else {\n      optionName = e.name;\n      optionValue = this._optionValueGetter(e.name);\n    }\n\n    if (optionValue === undefined || optionValue === null) {\n      return;\n    }\n\n    this._setGuard(optionName, optionValue);\n  };\n\n  OptionsManager.prototype.processChangedValues = function (newProps, prevProps) {\n    var _this = this;\n\n    this._updatingProps = false;\n\n    for (var _i = 0, _a = Object.keys(newProps); _i < _a.length; _i++) {\n      var optionName = _a[_i];\n\n      if (newProps[optionName] === prevProps[optionName]) {\n        continue;\n      }\n\n      if (this._guards[optionName]) {\n        window.clearTimeout(this._guards[optionName]);\n        delete this._guards[optionName];\n      }\n\n      if (!this._updatingProps) {\n        this._instance.beginUpdate();\n\n        this._updatingProps = true;\n      }\n\n      this._setOption(optionName, newProps[optionName]);\n    }\n\n    if (this._updatingProps) {\n      this._updatingProps = false;\n\n      this._instance.endUpdate();\n    }\n\n    Object.keys(this._dirtyOptions).forEach(function (optionName) {\n      var optionDescr = _this._dirtyOptions[optionName];\n\n      var optionValue = _this._getNestedOptionObj(optionDescr, false);\n\n      _this._setOption(optionName, optionValue);\n    });\n    this._dirtyOptions = {};\n  };\n\n  OptionsManager.prototype.getNestedOptionsObjects = function () {\n    return this._getNestedOptionsObjects(this._nestedOptions, true);\n  };\n\n  OptionsManager.prototype.registerNestedOption = function (component, expectedChildren) {\n    return this._registerNestedOption(component, expectedChildren, this._nestedOptions);\n  };\n\n  OptionsManager.prototype.dispose = function () {\n    for (var _i = 0, _a = Object.keys(this._guards); _i < _a.length; _i++) {\n      var optionName = _a[_i];\n      window.clearTimeout(this._guards[optionName]);\n      delete this._guards[optionName];\n    }\n  };\n\n  OptionsManager.prototype._setOption = function (name, value) {\n    var actualValue = value;\n\n    if (isEventHanlder(name, value)) {\n      actualValue = this._wrapEventHandler(value);\n    }\n\n    this._instance.option(name, actualValue);\n  };\n\n  OptionsManager.prototype._wrapEventHandler = function (handler) {\n    var _this = this;\n\n    return function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      if (!_this._updatingProps) {\n        handler.apply(void 0, args);\n      }\n    };\n  };\n\n  OptionsManager.prototype._getNestedOptionsObjects = function (optionsCollection, templateRegistrationRequired) {\n    var _this = this;\n\n    var configComponents = {};\n    Object.keys(optionsCollection).forEach(function (key) {\n      var configComponent = optionsCollection[key];\n      configComponents[configComponent.optionName] = _this._getNestedOptionObj(configComponent, templateRegistrationRequired);\n    });\n    return configComponents;\n  };\n\n  OptionsManager.prototype._getNestedOptionObj = function (configComponent, templateRegistrationRequired) {\n    var _this = this;\n\n    var options = configComponent.elementEntries.map(function (e, index) {\n      var props = widget_config_1.separateProps(e.element.props, configComponent.defaults, configComponent.templates);\n\n      var nestedObjects = _this._getNestedOptionsObjects(e.children, templateRegistrationRequired);\n\n      var nestedObjectsCount = Object.keys(nestedObjects).reduce(function (acc, item) {\n        var obj = nestedObjects[item];\n        return acc + (Array.isArray(obj) ? obj.length : 1);\n      }, 0);\n      var hasChildrenForTemplate = react_1.Children.count(e.element.props.children) > nestedObjectsCount;\n\n      if (templateRegistrationRequired) {\n        _this._templateHost.add({\n          useChildren: function useChildren(optionName) {\n            return optionName === \"template\" && hasChildrenForTemplate;\n          },\n          props: props.templates,\n          templateProps: configComponent.templates,\n          ownerName: _this.buildOptionItemName(configComponent, configComponent.isCollectionItem ? index : undefined),\n          propsGetter: function propsGetter(prop) {\n            return configComponent.elementEntries[index].element.props[prop];\n          }\n        });\n      }\n\n      return __assign({}, e.predefinedProps, props.defaults, props.options, nestedObjects);\n    });\n    return configComponent.isCollectionItem ? options : options[options.length - 1];\n  };\n\n  OptionsManager.prototype._registerNestedOption = function (element, expectedChildren, owningCollection, ownerFullName) {\n    var _this = this;\n\n    var nestedOptionClass = element;\n\n    if (!(nestedOptionClass && nestedOptionClass.type && nestedOptionClass.type.OptionName)) {\n      return null;\n    }\n\n    var nestedOptionsCollection = {};\n    var resolvedNested = resolveNestedOption(nestedOptionClass.type.OptionName, nestedOptionClass.type.IsCollectionItem, expectedChildren);\n    var optionName = resolvedNested.optionName;\n    var isCollectionItem = resolvedNested.isCollectionItem;\n    var optionFullName = optionName;\n\n    if (ownerFullName) {\n      optionFullName = ownerFullName + \".\" + optionFullName;\n    }\n\n    var option = ensureNestedOption(optionName, optionFullName, owningCollection, nestedOptionClass.type.DefaultsProps, nestedOptionClass.type.TemplateProps, isCollectionItem);\n    var optionItemName = this.buildOptionItemName(option, isCollectionItem ? option.elementEntries.length : undefined);\n    var nestedOptionMeta = {\n      optionName: optionName,\n      registerNestedOption: function registerNestedOption(c) {\n        return _this._registerNestedOption(c, nestedOptionClass.type.ExpectedChildren, nestedOptionsCollection, optionItemName);\n      },\n      updateFunc: function updateFunc(newProps, prevProps) {\n        var newOptions = widget_config_1.separateProps(newProps, nestedOptionClass.type.DefaultsProps, nestedOptionClass.type.TemplateProps).options;\n\n        _this.processChangedValues(helpers_1.addPrefixToKeys(newOptions, optionItemName + \".\"), helpers_1.addPrefixToKeys(prevProps, optionItemName + \".\"));\n      },\n      makeDirty: function makeDirty() {\n        if (_this._instance && option.isCollectionItem) {\n          _this._dirtyOptions[option.optionName] = option;\n        }\n      }\n    };\n    var optionComponent = nested_option_1.createOptionComponent(element, nestedOptionMeta);\n    option.elementEntries.push({\n      element: element,\n      children: nestedOptionsCollection,\n      predefinedProps: nestedOptionClass.type.PredefinedProps\n    });\n    return optionComponent;\n  };\n\n  OptionsManager.prototype.buildOptionItemName = function (descr, index) {\n    var optionItemName = descr.optionFullName;\n\n    if (index !== undefined) {\n      optionItemName += \"[\" + index + \"]\";\n    }\n\n    return optionItemName;\n  };\n\n  OptionsManager.prototype._setGuard = function (optionName, optionValue) {\n    var _this = this;\n\n    if (this._guards[optionName] !== undefined) {\n      return;\n    }\n\n    var guardId = window.setTimeout(function () {\n      _this._setOption(optionName, optionValue);\n\n      window.clearTimeout(guardId);\n      delete _this._guards[optionName];\n    });\n    this._guards[optionName] = guardId;\n  };\n\n  return OptionsManager;\n}();\n\nfunction ensureNestedOption(optionName, optionFullName, optionsCollection, defaults, templates, isCollectionItem) {\n  if (optionsCollection[optionName] === null || optionsCollection[optionName] === undefined) {\n    optionsCollection[optionName] = {\n      optionName: optionName,\n      optionFullName: optionFullName,\n      defaults: defaults,\n      templates: templates,\n      elementEntries: [],\n      isCollectionItem: isCollectionItem\n    };\n  }\n\n  return optionsCollection[optionName];\n}\n\nfunction resolveNestedOption(componentName, canBeCollectionItem, expectations) {\n  var optionName = componentName;\n  var isCollectionItem = canBeCollectionItem;\n  var expectation = expectations && expectations[componentName];\n\n  if (expectation) {\n    isCollectionItem = expectation.isCollectionItem;\n\n    if (expectation.optionName) {\n      optionName = expectation.optionName;\n    }\n  }\n\n  return {\n    optionName: optionName,\n    isCollectionItem: isCollectionItem\n  };\n}\n\nexports.resolveNestedOption = resolveNestedOption;\nexports.default = OptionsManager;","map":null,"metadata":{},"sourceType":"script"}