{"ast":null,"code":"/**\r\n * DevExtreme (ui/overlay/ui.overlay.js)\r\n * Version: 18.2.8\r\n * Build date: Tue Apr 23 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _typeof = \"function\" === typeof Symbol && \"symbol\" === typeof Symbol.iterator ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && \"function\" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar $ = require(\"../../core/renderer\"),\n    domAdapter = require(\"../../core/dom_adapter\"),\n    windowUtils = require(\"../../core/utils/window\"),\n    ready = require(\"../../core/utils/ready_callbacks\").add,\n    window = windowUtils.getWindow(),\n    navigator = windowUtils.getNavigator(),\n    eventsEngine = require(\"../../events/core/events_engine\"),\n    fx = require(\"../../animation/fx\"),\n    translator = require(\"../../animation/translator\"),\n    compareVersions = require(\"../../core/utils/version\").compare,\n    viewPortUtils = require(\"../../core/utils/view_port\"),\n    extend = require(\"../../core/utils/extend\").extend,\n    inArray = require(\"../../core/utils/array\").inArray,\n    getPublicElement = require(\"../../core/utils/dom\").getPublicElement,\n    viewPortChanged = viewPortUtils.changeCallback,\n    hideTopOverlayCallback = require(\"../../mobile/hide_top_overlay\").hideCallback,\n    positionUtils = require(\"../../animation/position\"),\n    fitIntoRange = require(\"../../core/utils/math\").fitIntoRange,\n    domUtils = require(\"../../core/utils/dom\"),\n    noop = require(\"../../core/utils/common\").noop,\n    typeUtils = require(\"../../core/utils/type\"),\n    each = require(\"../../core/utils/iterator\").each,\n    devices = require(\"../../core/devices\"),\n    browser = require(\"../../core/utils/browser\"),\n    registerComponent = require(\"../../core/component_registrator\"),\n    Widget = require(\"../widget/ui.widget\"),\n    KeyboardProcessor = require(\"../widget/ui.keyboard_processor\"),\n    selectors = require(\"../widget/selectors\"),\n    dragEvents = require(\"../../events/drag\"),\n    eventUtils = require(\"../../events/utils\"),\n    pointerEvents = require(\"../../events/pointer\"),\n    Resizable = require(\"../resizable\"),\n    EmptyTemplate = require(\"../widget/empty_template\"),\n    Deferred = require(\"../../core/utils/deferred\").Deferred,\n    zIndexPool = require(\"./z_index\"),\n    swatch = require(\"../widget/swatch_container\");\n\nvar OVERLAY_CLASS = \"dx-overlay\",\n    OVERLAY_WRAPPER_CLASS = \"dx-overlay-wrapper\",\n    OVERLAY_CONTENT_CLASS = \"dx-overlay-content\",\n    OVERLAY_SHADER_CLASS = \"dx-overlay-shader\",\n    OVERLAY_MODAL_CLASS = \"dx-overlay-modal\",\n    INNER_OVERLAY_CLASS = \"dx-inner-overlay\",\n    INVISIBLE_STATE_CLASS = \"dx-state-invisible\",\n    ANONYMOUS_TEMPLATE_NAME = \"content\",\n    RTL_DIRECTION_CLASS = \"dx-rtl\",\n    ACTIONS = [\"onShowing\", \"onShown\", \"onHiding\", \"onHidden\", \"onPositioning\", \"onPositioned\", \"onResizeStart\", \"onResize\", \"onResizeEnd\"],\n    OVERLAY_STACK = [],\n    DISABLED_STATE_CLASS = \"dx-state-disabled\",\n    TAB_KEY = \"tab\",\n    POSITION_ALIASES = {\n  top: {\n    my: \"top center\",\n    at: \"top center\"\n  },\n  bottom: {\n    my: \"bottom center\",\n    at: \"bottom center\"\n  },\n  right: {\n    my: \"right center\",\n    at: \"right center\"\n  },\n  left: {\n    my: \"left center\",\n    at: \"left center\"\n  },\n  center: {\n    my: \"center\",\n    at: \"center\"\n  },\n  \"right bottom\": {\n    my: \"right bottom\",\n    at: \"right bottom\"\n  },\n  \"right top\": {\n    my: \"right top\",\n    at: \"right top\"\n  },\n  \"left bottom\": {\n    my: \"left bottom\",\n    at: \"left bottom\"\n  },\n  \"left top\": {\n    my: \"left top\",\n    at: \"left top\"\n  }\n};\nvar realDevice = devices.real(),\n    realVersion = realDevice.version,\n    firefoxDesktop = browser.mozilla && \"desktop\" === realDevice.deviceType,\n    iOS = \"ios\" === realDevice.platform,\n    hasSafariAddressBar = browser.safari && \"desktop\" !== realDevice.deviceType,\n    iOS7_0andBelow = iOS && compareVersions(realVersion, [7, 1]) < 0,\n    android4_0nativeBrowser = \"android\" === realDevice.platform && 0 === compareVersions(realVersion, [4, 0], 2) && navigator.userAgent.indexOf(\"Chrome\") === -1;\n\nvar forceRepaint = function forceRepaint($element) {\n  if (iOS7_0andBelow || firefoxDesktop) {\n    $element.width();\n  }\n\n  if (android4_0nativeBrowser) {\n    var $parents = $element.parents(),\n        inScrollView = $parents.is(\".dx-scrollable-native\");\n\n    if (!inScrollView) {\n      $parents.css(\"backfaceVisibility\", \"hidden\");\n      $parents.css(\"backfaceVisibility\");\n      $parents.css(\"backfaceVisibility\", \"visible\");\n    }\n  }\n};\n\nvar getElement = function getElement(value) {\n  return value && $(value.target || value);\n};\n\nready(function () {\n  eventsEngine.subscribeGlobal(domAdapter.getDocument(), pointerEvents.down, function (e) {\n    for (var i = OVERLAY_STACK.length - 1; i >= 0; i--) {\n      if (!OVERLAY_STACK[i]._proxiedDocumentDownHandler(e)) {\n        return;\n      }\n    }\n  });\n});\nvar Overlay = Widget.inherit({\n  _supportedKeys: function _supportedKeys() {\n    var offsetSize = 5,\n        move = function move(top, left, e) {\n      if (!this.option(\"dragEnabled\")) {\n        return;\n      }\n\n      e.preventDefault();\n      e.stopPropagation();\n\n      var allowedOffsets = this._allowedOffsets();\n\n      var offset = {\n        top: fitIntoRange(top, -allowedOffsets.top, allowedOffsets.bottom),\n        left: fitIntoRange(left, -allowedOffsets.left, allowedOffsets.right)\n      };\n\n      this._changePosition(offset);\n    };\n\n    return extend(this.callBase(), {\n      escape: function escape() {\n        this.hide();\n      },\n      upArrow: move.bind(this, -offsetSize, 0),\n      downArrow: move.bind(this, offsetSize, 0),\n      leftArrow: move.bind(this, 0, -offsetSize),\n      rightArrow: move.bind(this, 0, offsetSize)\n    });\n  },\n  _getDefaultOptions: function _getDefaultOptions() {\n    return extend(this.callBase(), {\n      activeStateEnabled: false,\n      visible: false,\n      deferRendering: true,\n      shading: true,\n      shadingColor: \"\",\n      position: {\n        my: \"center\",\n        at: \"center\"\n      },\n      width: function width() {\n        return .8 * $(window).width();\n      },\n      minWidth: null,\n      maxWidth: null,\n      height: function height() {\n        return .8 * $(window).height();\n      },\n      minHeight: null,\n      maxHeight: null,\n      animation: {\n        show: {\n          type: \"pop\",\n          duration: 300,\n          from: {\n            scale: .55\n          }\n        },\n        hide: {\n          type: \"pop\",\n          duration: 300,\n          to: {\n            opacity: 0,\n            scale: .55\n          },\n          from: {\n            opacity: 1,\n            scale: 1\n          }\n        }\n      },\n      closeOnOutsideClick: false,\n      closeOnBackButton: true,\n      onShowing: null,\n      onShown: null,\n      onHiding: null,\n      onHidden: null,\n      contentTemplate: \"content\",\n      dragEnabled: false,\n      resizeEnabled: false,\n      onResizeStart: null,\n      onResize: null,\n      onResizeEnd: null,\n      innerOverlay: false,\n      target: void 0,\n      container: void 0,\n      hideTopOverlayHandler: void 0,\n      closeOnTargetScroll: false,\n      onPositioned: null,\n      boundaryOffset: {\n        h: 0,\n        v: 0\n      },\n      propagateOutsideClick: false,\n      ignoreChildEvents: true,\n      _checkParentVisibility: true\n    });\n  },\n  _defaultOptionsRules: function _defaultOptionsRules() {\n    return this.callBase().concat([{\n      device: function device() {\n        var realDevice = devices.real(),\n            realPlatform = realDevice.platform,\n            realVersion = realDevice.version;\n        return \"android\" === realPlatform && compareVersions(realVersion, [4, 2]) < 0;\n      },\n      options: {\n        animation: {\n          show: {\n            type: \"fade\",\n            duration: 400\n          },\n          hide: {\n            type: \"fade\",\n            duration: 400,\n            to: {\n              opacity: 0\n            },\n            from: {\n              opacity: 1\n            }\n          }\n        }\n      }\n    }, {\n      device: function device() {\n        return !windowUtils.hasWindow();\n      },\n      options: {\n        width: null,\n        height: null,\n        animation: null,\n        _checkParentVisibility: false\n      }\n    }]);\n  },\n  _setOptionsByReference: function _setOptionsByReference() {\n    this.callBase();\n    extend(this._optionsByReference, {\n      animation: true\n    });\n  },\n  _getAnonymousTemplateName: function _getAnonymousTemplateName() {\n    return ANONYMOUS_TEMPLATE_NAME;\n  },\n  _wrapper: function _wrapper() {\n    return this._$wrapper;\n  },\n  _container: function _container() {\n    return this._$content;\n  },\n  _eventBindingTarget: function _eventBindingTarget() {\n    return this._$content;\n  },\n  _init: function _init() {\n    this.callBase();\n\n    this._initActions();\n\n    this._initCloseOnOutsideClickHandler();\n\n    this._initTabTerminatorHandler();\n\n    this._$wrapper = $(\"<div>\").addClass(OVERLAY_WRAPPER_CLASS);\n    this._$content = $(\"<div>\").addClass(OVERLAY_CONTENT_CLASS);\n\n    this._initInnerOverlayClass();\n\n    var $element = this.$element();\n\n    this._$wrapper.addClass($element.attr(\"class\"));\n\n    $element.addClass(OVERLAY_CLASS);\n\n    this._$wrapper.attr(\"data-bind\", \"dxControlsDescendantBindings: true\");\n\n    eventsEngine.on(this._$wrapper, \"MSPointerDown\", noop);\n    eventsEngine.on(this._$wrapper, \"focusin\", function (e) {\n      e.stopPropagation();\n    });\n\n    this._toggleViewPortSubscription(true);\n  },\n  _initOptions: function _initOptions(options) {\n    this._initTarget(options.target);\n\n    this._initContainer(options.container);\n\n    this._initHideTopOverlayHandler(options.hideTopOverlayHandler);\n\n    this.callBase(options);\n  },\n  _initInnerOverlayClass: function _initInnerOverlayClass() {\n    this._$content.toggleClass(INNER_OVERLAY_CLASS, this.option(\"innerOverlay\"));\n  },\n  _initTarget: function _initTarget(target) {\n    if (!typeUtils.isDefined(target)) {\n      return;\n    }\n\n    var options = this.option();\n    each([\"position.of\", \"animation.show.from.position.of\", \"animation.show.to.position.of\", \"animation.hide.from.position.of\", \"animation.hide.to.position.of\"], function (_, path) {\n      var pathParts = path.split(\".\");\n      var option = options;\n\n      while (option) {\n        if (1 === pathParts.length) {\n          if (typeUtils.isPlainObject(option)) {\n            option[pathParts.shift()] = target;\n          }\n\n          break;\n        } else {\n          option = option[pathParts.shift()];\n        }\n      }\n    });\n  },\n  _initContainer: function _initContainer(container) {\n    container = void 0 === container ? viewPortUtils.value() : container;\n    var $element = this.$element();\n    var $container = $element.closest(container);\n\n    if (!$container.length) {\n      $container = $(container).first();\n    }\n\n    this._$container = $container.length ? $container : $element.parent();\n  },\n  _initHideTopOverlayHandler: function _initHideTopOverlayHandler(handler) {\n    this._hideTopOverlayHandler = void 0 !== handler ? handler : this._defaultHideTopOverlayHandler.bind(this);\n  },\n  _defaultHideTopOverlayHandler: function _defaultHideTopOverlayHandler() {\n    this.hide();\n  },\n  _initActions: function _initActions() {\n    this._actions = {};\n    each(ACTIONS, function (_, action) {\n      this._actions[action] = this._createActionByOption(action, {\n        excludeValidators: [\"disabled\", \"readOnly\"]\n      }) || noop;\n    }.bind(this));\n  },\n  _initCloseOnOutsideClickHandler: function _initCloseOnOutsideClickHandler() {\n    var that = this;\n\n    this._proxiedDocumentDownHandler = function () {\n      return that._documentDownHandler.apply(that, arguments);\n    };\n  },\n  _documentDownHandler: function _documentDownHandler(e) {\n    if (this._showAnimationProcessing) {\n      this._stopAnimation();\n    }\n\n    var closeOnOutsideClick = this.option(\"closeOnOutsideClick\");\n\n    if (typeUtils.isFunction(closeOnOutsideClick)) {\n      closeOnOutsideClick = closeOnOutsideClick(e);\n    }\n\n    var $container = this._$content,\n        isAttachedTarget = $(window.document).is(e.target) || domUtils.contains(window.document, e.target),\n        isInnerOverlay = $(e.target).closest(\".\" + INNER_OVERLAY_CLASS).length,\n        outsideClick = isAttachedTarget && !isInnerOverlay && !($container.is(e.target) || domUtils.contains($container.get(0), e.target));\n\n    if (outsideClick && closeOnOutsideClick) {\n      if (this.option(\"shading\")) {\n        e.preventDefault();\n      }\n\n      this.hide();\n    }\n\n    return this.option(\"propagateOutsideClick\");\n  },\n  _initTemplates: function _initTemplates() {\n    this.callBase();\n    this._defaultTemplates.content = new EmptyTemplate(this);\n  },\n  _isTopOverlay: function _isTopOverlay() {\n    var overlayStack = this._overlayStack();\n\n    for (var i = overlayStack.length - 1; i >= 0; i--) {\n      var tabbableElements = overlayStack[i]._findTabbableBounds();\n\n      if (tabbableElements.first || tabbableElements.last) {\n        return overlayStack[i] === this;\n      }\n    }\n\n    return false;\n  },\n  _overlayStack: function _overlayStack() {\n    return OVERLAY_STACK;\n  },\n  _zIndexInitValue: function _zIndexInitValue() {\n    return Overlay.baseZIndex();\n  },\n  _toggleViewPortSubscription: function _toggleViewPortSubscription(toggle) {\n    viewPortChanged.remove(this._viewPortChangeHandle);\n\n    if (toggle) {\n      this._viewPortChangeHandle = this._viewPortChangeHandler.bind(this);\n      viewPortChanged.add(this._viewPortChangeHandle);\n    }\n  },\n  _viewPortChangeHandler: function _viewPortChangeHandler() {\n    this._initContainer(this.option(\"container\"));\n\n    this._refresh();\n  },\n  _renderVisibilityAnimate: function _renderVisibilityAnimate(visible) {\n    this._stopAnimation();\n\n    return visible ? this._show() : this._hide();\n  },\n  _normalizePosition: function _normalizePosition() {\n    var position = this.option(\"position\");\n    this._position = \"function\" === typeof position ? position() : position;\n  },\n  _getAnimationConfig: function _getAnimationConfig() {\n    var animation = this.option(\"animation\");\n\n    if (typeUtils.isFunction(animation)) {\n      animation = animation.call(this);\n    }\n\n    return animation;\n  },\n  _show: function _show() {\n    var that = this,\n        deferred = new Deferred();\n    this._parentHidden = this._isParentHidden();\n    deferred.done(function () {\n      delete that._parentHidden;\n    });\n\n    if (this._parentHidden) {\n      return deferred.resolve();\n    }\n\n    if (this._currentVisible) {\n      return new Deferred().resolve().promise();\n    }\n\n    this._currentVisible = true;\n\n    this._normalizePosition();\n\n    var animation = that._getAnimationConfig() || {},\n        showAnimation = this._normalizeAnimation(animation.show, \"to\"),\n        startShowAnimation = showAnimation && showAnimation.start || noop,\n        completeShowAnimation = showAnimation && showAnimation.complete || noop;\n\n    if (this._isHidingActionCanceled) {\n      delete this._isHidingActionCanceled;\n      deferred.resolve();\n    } else {\n      var show = function () {\n        this._renderVisibility(true);\n\n        this._animate(showAnimation, function () {\n          if (that.option(\"focusStateEnabled\")) {\n            eventsEngine.trigger(that._focusTarget(), \"focus\");\n          }\n\n          completeShowAnimation.apply(this, arguments);\n          that._showAnimationProcessing = false;\n\n          that._actions.onShown();\n\n          deferred.resolve();\n        }, function () {\n          startShowAnimation.apply(this, arguments);\n          that._showAnimationProcessing = true;\n        });\n      }.bind(this);\n\n      if (this.option(\"templatesRenderAsynchronously\")) {\n        this._stopShowTimer();\n\n        this._asyncShowTimeout = setTimeout(show);\n      } else {\n        show();\n      }\n    }\n\n    return deferred.promise();\n  },\n  _normalizeAnimation: function _normalizeAnimation(animation, prop) {\n    if (animation) {\n      animation = extend({\n        type: \"slide\"\n      }, animation);\n\n      if (animation[prop] && \"object\" === _typeof(animation[prop])) {\n        extend(animation[prop], {\n          position: this._position\n        });\n      }\n    }\n\n    return animation;\n  },\n  _hide: function _hide() {\n    if (!this._currentVisible) {\n      return new Deferred().resolve().promise();\n    }\n\n    this._currentVisible = false;\n\n    var that = this,\n        deferred = new Deferred(),\n        animation = that._getAnimationConfig() || {},\n        hideAnimation = this._normalizeAnimation(animation.hide, \"from\"),\n        startHideAnimation = hideAnimation && hideAnimation.start || noop,\n        completeHideAnimation = hideAnimation && hideAnimation.complete || noop,\n        hidingArgs = {\n      cancel: false\n    };\n\n    this._actions.onHiding(hidingArgs);\n\n    if (hidingArgs.cancel) {\n      this._isHidingActionCanceled = true;\n      this.option(\"visible\", true);\n      deferred.resolve();\n    } else {\n      this._forceFocusLost();\n\n      this._toggleShading(false);\n\n      this._toggleSubscriptions(false);\n\n      this._stopShowTimer();\n\n      this._animate(hideAnimation, function () {\n        that._$content.css(\"pointerEvents\", \"\");\n\n        that._renderVisibility(false);\n\n        completeHideAnimation.apply(this, arguments);\n\n        that._actions.onHidden();\n\n        deferred.resolve();\n      }, function () {\n        that._$content.css(\"pointerEvents\", \"none\");\n\n        startHideAnimation.apply(this, arguments);\n      });\n    }\n\n    return deferred.promise();\n  },\n  _forceFocusLost: function _forceFocusLost() {\n    var activeElement = domAdapter.getActiveElement();\n    activeElement && this._$content.find(activeElement).length && activeElement.blur();\n  },\n  _animate: function _animate(animation, completeCallback, startCallback) {\n    if (animation) {\n      startCallback = startCallback || animation.start || noop;\n      fx.animate(this._$content, extend({}, animation, {\n        start: startCallback,\n        complete: completeCallback\n      }));\n    } else {\n      completeCallback();\n    }\n  },\n  _stopAnimation: function _stopAnimation() {\n    fx.stop(this._$content, true);\n  },\n  _renderVisibility: function _renderVisibility(visible) {\n    if (visible && this._isParentHidden()) {\n      return;\n    }\n\n    this._currentVisible = visible;\n\n    this._stopAnimation();\n\n    if (!visible) {\n      domUtils.triggerHidingEvent(this._$content);\n    }\n\n    this._toggleVisibility(visible);\n\n    this._$content.toggleClass(INVISIBLE_STATE_CLASS, !visible);\n\n    this._updateZIndexStackPosition(visible);\n\n    if (visible) {\n      this._renderContent();\n\n      this._actions.onShowing();\n\n      this._moveToContainer();\n\n      this._renderGeometry();\n\n      domUtils.triggerShownEvent(this._$content);\n      domUtils.triggerResizeEvent(this._$content);\n    } else {\n      this._moveFromContainer();\n    }\n\n    this._toggleShading(visible);\n\n    this._toggleSubscriptions(visible);\n  },\n  _updateZIndexStackPosition: function _updateZIndexStackPosition(pushToStack) {\n    var overlayStack = this._overlayStack(),\n        index = inArray(this, overlayStack);\n\n    if (pushToStack) {\n      if (index === -1) {\n        this._zIndex = zIndexPool.create(this._zIndexInitValue());\n        overlayStack.push(this);\n      }\n\n      this._$wrapper.css(\"zIndex\", this._zIndex);\n\n      this._$content.css(\"zIndex\", this._zIndex);\n    } else {\n      if (index !== -1) {\n        overlayStack.splice(index, 1);\n        zIndexPool.remove(this._zIndex);\n      }\n    }\n  },\n  _toggleShading: function _toggleShading(visible) {\n    this._$wrapper.toggleClass(OVERLAY_MODAL_CLASS, this.option(\"shading\") && !this.option(\"container\"));\n\n    this._$wrapper.toggleClass(OVERLAY_SHADER_CLASS, visible && this.option(\"shading\"));\n\n    this._$wrapper.css(\"backgroundColor\", this.option(\"shading\") ? this.option(\"shadingColor\") : \"\");\n\n    this._toggleTabTerminator(visible && this.option(\"shading\"));\n  },\n  _initTabTerminatorHandler: function _initTabTerminatorHandler() {\n    var that = this;\n\n    this._proxiedTabTerminatorHandler = function () {\n      that._tabKeyHandler.apply(that, arguments);\n    };\n  },\n  _toggleTabTerminator: function _toggleTabTerminator(enabled) {\n    var eventName = eventUtils.addNamespace(\"keydown\", this.NAME);\n\n    if (enabled) {\n      eventsEngine.on(domAdapter.getDocument(), eventName, this._proxiedTabTerminatorHandler);\n    } else {\n      eventsEngine.off(domAdapter.getDocument(), eventName, this._proxiedTabTerminatorHandler);\n    }\n  },\n  _findTabbableBounds: function _findTabbableBounds() {\n    var $elements = this._$wrapper.find(\"*\");\n\n    var elementsCount = $elements.length - 1;\n    var result = {\n      first: null,\n      last: null\n    };\n\n    for (var i = 0; i <= elementsCount; i++) {\n      if (!result.first && $elements.eq(i).is(selectors.tabbable)) {\n        result.first = $elements.eq(i);\n      }\n\n      if (!result.last && $elements.eq(elementsCount - i).is(selectors.tabbable)) {\n        result.last = $elements.eq(elementsCount - i);\n      }\n\n      if (result.first && result.last) {\n        break;\n      }\n    }\n\n    return result;\n  },\n  _tabKeyHandler: function _tabKeyHandler(e) {\n    if (eventUtils.normalizeKeyName(e) !== TAB_KEY || !this._isTopOverlay()) {\n      return;\n    }\n\n    var tabbableElements = this._findTabbableBounds(),\n        $firstTabbable = tabbableElements.first,\n        $lastTabbable = tabbableElements.last,\n        isTabOnLast = !e.shiftKey && e.target === $lastTabbable.get(0),\n        isShiftTabOnFirst = e.shiftKey && e.target === $firstTabbable.get(0),\n        isEmptyTabList = 0 === tabbableElements.length,\n        isOutsideTarget = !domUtils.contains(this._$wrapper.get(0), e.target);\n\n    if (isTabOnLast || isShiftTabOnFirst || isEmptyTabList || isOutsideTarget) {\n      e.preventDefault();\n      var $focusElement = e.shiftKey ? $lastTabbable : $firstTabbable;\n      eventsEngine.trigger($focusElement, \"focusin\");\n      eventsEngine.trigger($focusElement, \"focus\");\n    }\n  },\n  _toggleSubscriptions: function _toggleSubscriptions(enabled) {\n    if (windowUtils.hasWindow()) {\n      this._toggleHideTopOverlayCallback(enabled);\n\n      this._toggleParentsScrollSubscription(enabled);\n    }\n  },\n  _toggleHideTopOverlayCallback: function _toggleHideTopOverlayCallback(subscribe) {\n    if (!this._hideTopOverlayHandler) {\n      return;\n    }\n\n    if (subscribe && this.option(\"closeOnBackButton\")) {\n      hideTopOverlayCallback.add(this._hideTopOverlayHandler);\n    } else {\n      hideTopOverlayCallback.remove(this._hideTopOverlayHandler);\n    }\n  },\n  _toggleParentsScrollSubscription: function _toggleParentsScrollSubscription(subscribe) {\n    if (!this._position) {\n      return;\n    }\n\n    var target = this._position.of || $(),\n        closeOnScroll = this.option(\"closeOnTargetScroll\"),\n        $parents = getElement(target).parents(),\n        scrollEvent = eventUtils.addNamespace(\"scroll\", this.NAME);\n\n    if (\"generic\" === devices.real().platform) {\n      $parents = $parents.add(window);\n    }\n\n    this._proxiedTargetParentsScrollHandler = this._proxiedTargetParentsScrollHandler || function (e) {\n      this._targetParentsScrollHandler(e);\n    }.bind(this);\n\n    eventsEngine.off($().add(this._$prevTargetParents), scrollEvent, this._proxiedTargetParentsScrollHandler);\n\n    if (subscribe && closeOnScroll) {\n      eventsEngine.on($parents, scrollEvent, this._proxiedTargetParentsScrollHandler);\n      this._$prevTargetParents = $parents;\n    }\n  },\n  _targetParentsScrollHandler: function _targetParentsScrollHandler(e) {\n    var closeHandled = false,\n        closeOnScroll = this.option(\"closeOnTargetScroll\");\n\n    if (typeUtils.isFunction(closeOnScroll)) {\n      closeHandled = closeOnScroll(e);\n    }\n\n    if (!closeHandled && !this._showAnimationProcessing) {\n      this.hide();\n    }\n  },\n  _render: function _render() {\n    this.callBase();\n\n    this._$content.appendTo(this.$element());\n\n    this._renderVisibilityAnimate(this.option(\"visible\"));\n  },\n  _renderContent: function _renderContent() {\n    var shouldDeferRendering = !this._currentVisible && this.option(\"deferRendering\");\n\n    var isParentHidden = this.option(\"visible\") && this._isParentHidden();\n\n    if (isParentHidden) {\n      this._isHidden = true;\n      return;\n    }\n\n    if (this._contentAlreadyRendered || shouldDeferRendering) {\n      return;\n    }\n\n    this._contentAlreadyRendered = true;\n    this.callBase();\n  },\n  _isParentHidden: function _isParentHidden() {\n    if (!this.option(\"_checkParentVisibility\")) {\n      return false;\n    }\n\n    if (void 0 !== this._parentHidden) {\n      return this._parentHidden;\n    }\n\n    var $parent = this.$element().parent();\n\n    if ($parent.is(\":visible\")) {\n      return false;\n    }\n\n    var isHidden = false;\n    $parent.add($parent.parents()).each(function () {\n      var $element = $(this);\n\n      if (\"none\" === $element.css(\"display\")) {\n        isHidden = true;\n        return false;\n      }\n    });\n    return isHidden || !domAdapter.getBody().contains($parent.get(0));\n  },\n  _renderContentImpl: function _renderContentImpl() {\n    var _this = this;\n\n    var $element = this.$element();\n\n    this._$content.appendTo($element);\n\n    var whenContentRendered = new Deferred();\n\n    var contentTemplateOption = this.option(\"contentTemplate\"),\n        contentTemplate = this._getTemplate(contentTemplateOption),\n        transclude = this._getAnonymousTemplateName() === contentTemplateOption;\n\n    contentTemplate && contentTemplate.render({\n      container: getPublicElement(this.$content()),\n      noModel: true,\n      transclude: transclude,\n      onRendered: function onRendered() {\n        whenContentRendered.resolve();\n      }\n    });\n\n    this._renderDrag();\n\n    this._renderResize();\n\n    this._renderScrollTerminator();\n\n    whenContentRendered.done(function () {\n      if (_this.option(\"visible\")) {\n        _this._moveToContainer();\n      }\n    });\n    return whenContentRendered.promise();\n  },\n  _renderDrag: function _renderDrag() {\n    var $dragTarget = this._getDragTarget();\n\n    if (!$dragTarget) {\n      return;\n    }\n\n    var startEventName = eventUtils.addNamespace(dragEvents.start, this.NAME),\n        updateEventName = eventUtils.addNamespace(dragEvents.move, this.NAME);\n    eventsEngine.off($dragTarget, startEventName);\n    eventsEngine.off($dragTarget, updateEventName);\n\n    if (!this.option(\"dragEnabled\")) {\n      return;\n    }\n\n    eventsEngine.on($dragTarget, startEventName, this._dragStartHandler.bind(this));\n    eventsEngine.on($dragTarget, updateEventName, this._dragUpdateHandler.bind(this));\n  },\n  _renderResize: function _renderResize() {\n    this._resizable = this._createComponent(this._$content, Resizable, {\n      handles: this.option(\"resizeEnabled\") ? \"all\" : \"none\",\n      onResizeEnd: this._resizeEndHandler.bind(this),\n      onResize: this._actions.onResize.bind(this),\n      onResizeStart: this._actions.onResizeStart.bind(this),\n      minHeight: 100,\n      minWidth: 100,\n      area: this._getDragResizeContainer()\n    });\n  },\n  _resizeEndHandler: function _resizeEndHandler() {\n    this._positionChangeHandled = true;\n\n    var width = this._resizable.option(\"width\"),\n        height = this._resizable.option(\"height\");\n\n    width && this.option(\"width\", width);\n    height && this.option(\"height\", height);\n\n    this._actions.onResizeEnd();\n  },\n  _renderScrollTerminator: function _renderScrollTerminator() {\n    var $scrollTerminator = this._wrapper();\n\n    var terminatorEventName = eventUtils.addNamespace(dragEvents.move, this.NAME);\n    eventsEngine.off($scrollTerminator, terminatorEventName);\n    eventsEngine.on($scrollTerminator, terminatorEventName, {\n      validate: function validate() {\n        return true;\n      },\n      getDirection: function getDirection() {\n        return \"both\";\n      },\n      _toggleGestureCover: noop,\n      _clearSelection: noop,\n      isNative: true\n    }, function (e) {\n      var originalEvent = e.originalEvent.originalEvent;\n      e._cancelPreventDefault = true;\n\n      if (originalEvent && \"mousemove\" !== originalEvent.type) {\n        e.preventDefault();\n      }\n    });\n  },\n  _getDragTarget: function _getDragTarget() {\n    return this.$content();\n  },\n  _dragStartHandler: function _dragStartHandler(e) {\n    e.targetElements = [];\n    this._prevOffset = {\n      x: 0,\n      y: 0\n    };\n\n    var allowedOffsets = this._allowedOffsets();\n\n    e.maxTopOffset = allowedOffsets.top;\n    e.maxBottomOffset = allowedOffsets.bottom;\n    e.maxLeftOffset = allowedOffsets.left;\n    e.maxRightOffset = allowedOffsets.right;\n  },\n  _getDragResizeContainer: function _getDragResizeContainer() {\n    var isContainerDefined = viewPortUtils.originalViewPort().get(0) || this.option(\"container\"),\n        $container = !isContainerDefined ? $(window) : this._$container;\n    return $container;\n  },\n  _deltaSize: function _deltaSize() {\n    var $content = this._$content,\n        $container = this._getDragResizeContainer();\n\n    var contentWidth = $content.outerWidth(),\n        contentHeight = $content.outerHeight(),\n        containerWidth = $container.outerWidth(),\n        containerHeight = $container.outerHeight();\n\n    if (this._isWindow($container)) {\n      var document = domAdapter.getDocument(),\n          fullPageHeight = Math.max($(document).outerHeight(), containerHeight),\n          fullPageWidth = Math.max($(document).outerWidth(), containerWidth);\n      containerHeight = fullPageHeight;\n      containerWidth = fullPageWidth;\n    }\n\n    return {\n      width: containerWidth - contentWidth,\n      height: containerHeight - contentHeight\n    };\n  },\n  _dragUpdateHandler: function _dragUpdateHandler(e) {\n    var offset = e.offset,\n        prevOffset = this._prevOffset,\n        targetOffset = {\n      top: offset.y - prevOffset.y,\n      left: offset.x - prevOffset.x\n    };\n\n    this._changePosition(targetOffset);\n\n    this._prevOffset = offset;\n  },\n  _changePosition: function _changePosition(offset) {\n    var position = translator.locate(this._$content);\n    translator.move(this._$content, {\n      left: position.left + offset.left,\n      top: position.top + offset.top\n    });\n    this._positionChangeHandled = true;\n  },\n  _allowedOffsets: function _allowedOffsets() {\n    var position = translator.locate(this._$content),\n        deltaSize = this._deltaSize(),\n        isAllowedDrag = deltaSize.height >= 0 && deltaSize.width >= 0,\n        shaderOffset = this.option(\"shading\") && !this.option(\"container\") && !this._isWindow(this._getContainer()) ? translator.locate(this._$wrapper) : {\n      top: 0,\n      left: 0\n    },\n        boundaryOffset = this.option(\"boundaryOffset\");\n\n    return {\n      top: isAllowedDrag ? position.top + shaderOffset.top + boundaryOffset.v : 0,\n      bottom: isAllowedDrag ? -position.top - shaderOffset.top + deltaSize.height - boundaryOffset.v : 0,\n      left: isAllowedDrag ? position.left + shaderOffset.left + boundaryOffset.h : 0,\n      right: isAllowedDrag ? -position.left - shaderOffset.left + deltaSize.width - boundaryOffset.h : 0\n    };\n  },\n  _moveFromContainer: function _moveFromContainer() {\n    this._$content.appendTo(this.$element());\n\n    this._detachWrapperToContainer();\n  },\n  _detachWrapperToContainer: function _detachWrapperToContainer() {\n    this._$wrapper.detach();\n  },\n  _moveToContainer: function _moveToContainer() {\n    this._attachWrapperToContainer();\n\n    this._$content.appendTo(this._$wrapper);\n  },\n  _attachWrapperToContainer: function _attachWrapperToContainer() {\n    var $element = this.$element();\n    var containerDefined = void 0 !== this.option(\"container\");\n    var renderContainer = containerDefined ? this._$container : swatch.getSwatchContainer($element);\n\n    if (renderContainer && renderContainer[0] === $element.parent()[0]) {\n      renderContainer = $element;\n    }\n\n    this._$wrapper.appendTo(renderContainer);\n  },\n  _fixHeightAfterSafariAddressBarResizing: function _fixHeightAfterSafariAddressBarResizing() {\n    if (this._isWindow(this._getContainer()) && hasSafariAddressBar) {\n      this._$wrapper.css(\"minHeight\", window.innerHeight);\n    }\n  },\n  _renderGeometry: function _renderGeometry() {\n    if (this.option(\"visible\") && windowUtils.hasWindow()) {\n      this._renderGeometryImpl();\n    }\n  },\n  _renderGeometryImpl: function _renderGeometryImpl() {\n    this._stopAnimation();\n\n    this._normalizePosition();\n\n    this._fixHeightAfterSafariAddressBarResizing();\n\n    this._renderShading();\n\n    this._renderDimensions();\n\n    var resultPosition = this._renderPosition();\n\n    this._actions.onPositioned({\n      position: resultPosition\n    });\n  },\n  _renderShading: function _renderShading() {\n    var $wrapper = this._$wrapper,\n        $container = this._getContainer();\n\n    $wrapper.css(\"position\", this._isWindow($container) && !iOS ? \"fixed\" : \"absolute\");\n\n    this._renderShadingDimensions();\n\n    this._renderShadingPosition();\n  },\n  _renderShadingPosition: function _renderShadingPosition() {\n    if (this.option(\"shading\")) {\n      var $container = this._getContainer();\n\n      positionUtils.setup(this._$wrapper, {\n        my: \"top left\",\n        at: \"top left\",\n        of: $container\n      });\n    }\n  },\n  _renderShadingDimensions: function _renderShadingDimensions() {\n    var wrapperWidth, wrapperHeight;\n\n    if (this.option(\"shading\")) {\n      var $container = this._getContainer();\n\n      wrapperWidth = this._isWindow($container) ? \"100%\" : $container.outerWidth(), wrapperHeight = this._isWindow($container) ? \"100%\" : $container.outerHeight();\n    } else {\n      wrapperWidth = \"\";\n      wrapperHeight = \"\";\n    }\n\n    this._$wrapper.css({\n      width: wrapperWidth,\n      height: wrapperHeight\n    });\n  },\n  _isWindow: function _isWindow($element) {\n    return !!$element && typeUtils.isWindow($element.get(0));\n  },\n  _getContainer: function _getContainer() {\n    var position = this._position,\n        container = this.option(\"container\"),\n        positionOf = position ? position.of || window : null;\n    return getElement(container || positionOf);\n  },\n  _renderDimensions: function _renderDimensions() {\n    var content = this._$content.get(0);\n\n    this._$content.css({\n      minWidth: this._getOptionValue(\"minWidth\", content),\n      maxWidth: this._getOptionValue(\"maxWidth\", content),\n      minHeight: this._getOptionValue(\"minHeight\", content),\n      maxHeight: this._getOptionValue(\"maxHeight\", content),\n      width: this._getOptionValue(\"width\", content),\n      height: this._getOptionValue(\"height\", content)\n    });\n  },\n  _renderPosition: function _renderPosition() {\n    if (this._positionChangeHandled) {\n      var allowedOffsets = this._allowedOffsets();\n\n      this._changePosition({\n        top: fitIntoRange(0, -allowedOffsets.top, allowedOffsets.bottom),\n        left: fitIntoRange(0, -allowedOffsets.left, allowedOffsets.right)\n      });\n    } else {\n      this._renderOverlayBoundaryOffset();\n\n      translator.resetPosition(this._$content);\n\n      var position = this._transformStringPosition(this._position, POSITION_ALIASES),\n          resultPosition = positionUtils.setup(this._$content, position);\n\n      forceRepaint(this._$content);\n\n      this._actions.onPositioning();\n\n      return resultPosition;\n    }\n  },\n  _transformStringPosition: function _transformStringPosition(position, positionAliases) {\n    if (typeUtils.isString(position)) {\n      position = extend({}, positionAliases[position]);\n    }\n\n    return position;\n  },\n  _renderOverlayBoundaryOffset: function _renderOverlayBoundaryOffset() {\n    var boundaryOffset = this.option(\"boundaryOffset\");\n\n    this._$content.css(\"margin\", boundaryOffset.v + \"px \" + boundaryOffset.h + \"px\");\n  },\n  _focusTarget: function _focusTarget() {\n    return this._$content;\n  },\n  _attachKeyboardEvents: function _attachKeyboardEvents() {\n    this._keyboardProcessor = new KeyboardProcessor({\n      element: this._$content,\n      handler: this._keyboardHandler,\n      context: this\n    });\n  },\n  _keyboardHandler: function _keyboardHandler(options) {\n    var e = options.originalEvent,\n        $target = $(e.target);\n\n    if ($target.is(this._$content) || !this.option(\"ignoreChildEvents\")) {\n      this.callBase.apply(this, arguments);\n    }\n  },\n  _isVisible: function _isVisible() {\n    return this.option(\"visible\");\n  },\n  _visibilityChanged: function _visibilityChanged(visible) {\n    if (visible) {\n      if (this.option(\"visible\")) {\n        this._renderVisibilityAnimate(visible);\n      }\n    } else {\n      this._renderVisibilityAnimate(visible);\n    }\n  },\n  _dimensionChanged: function _dimensionChanged() {\n    this._renderGeometry();\n  },\n  _clean: function _clean() {\n    if (!this._contentAlreadyRendered) {\n      this.$content().empty();\n    }\n\n    this._renderVisibility(false);\n\n    this._stopShowTimer();\n\n    this._cleanFocusState();\n  },\n  _stopShowTimer: function _stopShowTimer() {\n    if (this._asyncShowTimeout) {\n      clearTimeout(this._asyncShowTimeout);\n    }\n\n    this._asyncShowTimeout = null;\n  },\n  _dispose: function _dispose() {\n    fx.stop(this._$content, false);\n    clearTimeout(this._deferShowTimer);\n\n    this._toggleViewPortSubscription(false);\n\n    this._toggleSubscriptions(false);\n\n    this._updateZIndexStackPosition(false);\n\n    this._toggleTabTerminator(false);\n\n    this._actions = null;\n    this.callBase();\n    zIndexPool.remove(this._zIndex);\n\n    this._$wrapper.remove();\n\n    this._$content.remove();\n  },\n  _toggleDisabledState: function _toggleDisabledState(value) {\n    this.callBase.apply(this, arguments);\n\n    this._$content.toggleClass(DISABLED_STATE_CLASS, Boolean(value));\n  },\n  _toggleRTLDirection: function _toggleRTLDirection(rtl) {\n    this._$content.toggleClass(RTL_DIRECTION_CLASS, rtl);\n  },\n  _optionChanged: function _optionChanged(args) {\n    var value = args.value;\n\n    if (inArray(args.name, ACTIONS) > -1) {\n      this._initActions();\n\n      return;\n    }\n\n    switch (args.name) {\n      case \"dragEnabled\":\n        this._renderDrag();\n\n        this._renderGeometry();\n\n        break;\n\n      case \"resizeEnabled\":\n        this._renderResize();\n\n        this._renderGeometry();\n\n        break;\n\n      case \"shading\":\n      case \"shadingColor\":\n        this._toggleShading(this.option(\"visible\"));\n\n        break;\n\n      case \"width\":\n      case \"height\":\n      case \"minWidth\":\n      case \"maxWidth\":\n      case \"minHeight\":\n      case \"maxHeight\":\n      case \"boundaryOffset\":\n        this._renderGeometry();\n\n        break;\n\n      case \"position\":\n        this._positionChangeHandled = false;\n\n        this._renderGeometry();\n\n        break;\n\n      case \"visible\":\n        this._renderVisibilityAnimate(value).done(function () {\n          if (!this._animateDeferred) {\n            return;\n          }\n\n          this._animateDeferred.resolveWith(this);\n        }.bind(this));\n\n        break;\n\n      case \"target\":\n        this._initTarget(value);\n\n        this._invalidate();\n\n        break;\n\n      case \"container\":\n        this._initContainer(value);\n\n        this._invalidate();\n\n        break;\n\n      case \"innerOverlay\":\n        this._initInnerOverlayClass();\n\n        break;\n\n      case \"deferRendering\":\n      case \"contentTemplate\":\n        this._contentAlreadyRendered = false;\n\n        this._clean();\n\n        this._invalidate();\n\n        break;\n\n      case \"closeOnBackButton\":\n        this._toggleHideTopOverlayCallback(this.option(\"visible\"));\n\n        break;\n\n      case \"closeOnTargetScroll\":\n        this._toggleParentsScrollSubscription(this.option(\"visible\"));\n\n        break;\n\n      case \"closeOnOutsideClick\":\n      case \"animation\":\n      case \"propagateOutsideClick\":\n        break;\n\n      case \"rtlEnabled\":\n        this._contentAlreadyRendered = false;\n        this.option(\"visible\", false);\n        this.callBase(args);\n        break;\n\n      default:\n        this.callBase(args);\n    }\n  },\n  toggle: function toggle(showing) {\n    showing = void 0 === showing ? !this.option(\"visible\") : showing;\n\n    if (showing === this.option(\"visible\")) {\n      return new Deferred().resolve().promise();\n    }\n\n    var animateDeferred = new Deferred();\n    this._animateDeferred = animateDeferred;\n    this.option(\"visible\", showing);\n    return animateDeferred.promise().done(function () {\n      delete this._animateDeferred;\n    }.bind(this));\n  },\n  $content: function $content() {\n    return this._$content;\n  },\n  show: function show() {\n    return this.toggle(true);\n  },\n  hide: function hide() {\n    return this.toggle(false);\n  },\n  content: function content() {\n    return getPublicElement(this._$content);\n  },\n  repaint: function repaint() {\n    this._renderGeometry();\n  }\n});\n\nOverlay.baseZIndex = function (zIndex) {\n  return zIndexPool.base(zIndex);\n};\n\nregisterComponent(\"dxOverlay\", Overlay);\nmodule.exports = Overlay;","map":null,"metadata":{},"sourceType":"script"}