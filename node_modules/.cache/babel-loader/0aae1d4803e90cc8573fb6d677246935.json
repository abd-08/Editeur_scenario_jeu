{"ast":null,"code":"/*!\n * devextreme-react\n * Version: 18.2.8\n * Build date: Tue Apr 23 2019\n *\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\n *\n * This software may be modified and distributed under the terms\n * of the MIT license. See the LICENSE file in the root of the project for details.\n *\n * https://github.com/DevExpress/devextreme-react\n */\n\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) {\n      if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n  }\n\n  return t;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events = require(\"devextreme/events\");\n\nvar React = require(\"react\");\n\nvar options_manager_1 = require(\"./options-manager\");\n\nvar template_1 = require(\"./template\");\n\nvar template_host_1 = require(\"./template-host\");\n\nvar template_updater_1 = require(\"./template-updater\");\n\nvar widget_config_1 = require(\"./widget-config\");\n\nvar DX_REMOVE_EVENT = \"dxremove\";\nexports.DX_REMOVE_EVENT = DX_REMOVE_EVENT;\n\nvar ComponentBase =\n/** @class */\nfunction (_super) {\n  __extends(ComponentBase, _super);\n\n  function ComponentBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._templateProps = [];\n    _this._prepareProps = _this._prepareProps.bind(_this);\n    _this.state = {\n      templates: {}\n    };\n    _this._templateUpdater = new template_updater_1.TemplateUpdater(function (templates) {\n      _this.setState({\n        templates: __assign({}, templates)\n      });\n    });\n    _this._templateHost = new template_host_1.default(_this._templateUpdater);\n    _this._optionsManager = new options_manager_1.default(function (name) {\n      return _this.props[name];\n    }, _this._templateHost);\n    return _this;\n  }\n\n  ComponentBase.prototype.render = function () {\n    return React.createElement.apply(React, [\"div\", this._getElementProps()].concat(this._prepareChildren()));\n  };\n\n  ComponentBase.prototype.componentDidMount = function () {\n    this._updateCssClasses(null, this.props);\n  };\n\n  ComponentBase.prototype.componentDidUpdate = function (prevProps) {\n    this._updateCssClasses(prevProps, this.props);\n\n    var preparedProps = this._prepareProps(this.props);\n\n    var options = __assign({}, preparedProps.options, this._templateHost.options);\n\n    this._optionsManager.processChangedValues(options, prevProps);\n  };\n\n  ComponentBase.prototype.componentWillUnmount = function () {\n    if (this._instance) {\n      events.triggerHandler(this._element, DX_REMOVE_EVENT);\n\n      this._instance.dispose();\n    }\n\n    this._optionsManager.dispose();\n  };\n\n  ComponentBase.prototype._prepareChildren = function (args) {\n    var _this = this;\n\n    if (args === void 0) {\n      args = [];\n    }\n\n    this._optionsManager.resetNestedElements();\n\n    React.Children.forEach(this.props.children, function (child) {\n      args.push(_this._preprocessChild(child) || child);\n    });\n    var templates = Object.getOwnPropertyNames(this.state.templates) || [];\n    templates.forEach(function (t) {\n      args.push(_this.state.templates[t]());\n    });\n    return args;\n  };\n\n  ComponentBase.prototype._preprocessChild = function (component) {\n    var nestedTemplate = template_1.findProps(component);\n\n    if (nestedTemplate) {\n      this._templateHost.addNested(nestedTemplate);\n    }\n\n    return this._optionsManager.registerNestedOption(component, this._expectedChildren) || component;\n  };\n\n  ComponentBase.prototype._createWidget = function (element) {\n    element = element || this._element;\n\n    var nestedProps = this._optionsManager.getNestedOptionsObjects();\n\n    var props = __assign({}, this.props, nestedProps);\n\n    var preparedProps = this._prepareProps(props);\n\n    var options = __assign({\n      templatesRenderAsynchronously: true\n    }, preparedProps.defaults, preparedProps.options, this._templateHost.options);\n\n    this._optionsManager.wrapEventHandlers(options);\n\n    this._instance = new this._WidgetClass(element, options);\n\n    this._optionsManager.setInstance(this._instance);\n\n    this._instance.on(\"optionChanged\", this._optionsManager.handleOptionChange);\n  };\n\n  ComponentBase.prototype._getElementProps = function () {\n    var _this = this;\n\n    var elementProps = {\n      ref: function ref(element) {\n        return _this._element = element;\n      }\n    };\n    widget_config_1.elementPropNames.forEach(function (name) {\n      if (name in _this.props) {\n        elementProps[name] = _this.props[name];\n      }\n    });\n    return elementProps;\n  };\n\n  ComponentBase.prototype._updateCssClasses = function (prevProps, newProps) {\n    var _a, _b;\n\n    var prevClassName = prevProps ? widget_config_1.getClassName(prevProps) : undefined;\n    var newClassName = widget_config_1.getClassName(newProps);\n\n    if (prevClassName === newClassName) {\n      return;\n    }\n\n    if (prevClassName) {\n      var classNames = prevClassName.split(\" \").filter(function (c) {\n        return c;\n      });\n\n      if (classNames.length) {\n        (_a = this._element.classList).remove.apply(_a, classNames);\n      }\n    }\n\n    if (newClassName) {\n      var classNames = newClassName.split(\" \").filter(function (c) {\n        return c;\n      });\n\n      if (classNames.length) {\n        (_b = this._element.classList).add.apply(_b, classNames);\n      }\n    }\n  };\n\n  ComponentBase.prototype._prepareProps = function (rawProps) {\n    var _this = this;\n\n    var separatedProps = widget_config_1.separateProps(rawProps, this._defaults, this._templateProps);\n\n    this._templateHost.add({\n      useChildren: function useChildren() {\n        return false;\n      },\n      ownerName: \"\",\n      templateProps: this._templateProps,\n      props: separatedProps.templates,\n      propsGetter: function propsGetter(prop) {\n        return _this.props[prop];\n      }\n    });\n\n    return {\n      options: separatedProps.options,\n      defaults: separatedProps.defaults\n    };\n  };\n\n  return ComponentBase;\n}(React.PureComponent);\n\nexports.ComponentBase = ComponentBase;","map":null,"metadata":{},"sourceType":"script"}